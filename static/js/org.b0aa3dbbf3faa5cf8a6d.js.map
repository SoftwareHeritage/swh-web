{"version":3,"sources":["webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js","webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js"],"names":["exportModule","module","exportedName","hasOwnProperty","exports","Node","Converter","prototype","exportOptions","headerOffset","exportFromLineNumber","suppressSubScriptHandling","suppressAutoLink","translateSymbolArrow","suppressCheckboxHandling","customDirectiveHandler","htmlClassPrefix","htmlIdPrefix","untitled","result","initialize","orgDocument","this","documentOptions","options","headers","sectionNumbers","createTocItem","headerNode","parentTocs","childTocs","parent","computeToc","exportTocLevel","Infinity","toc","previousLevel","currentTocs","i","length","level","levelDiff","j","dummyHeader","createHeader","sectionNumberText","push","k","convertNode","node","recordHeader","insideCodeElement","type","types","directive","directiveName","preformatted","createText","value","text","childText","children","convertNodesInternal","auxData","computeAuxDataForNode","header","taskStatus","indexOf","thisHeaderLevel","previousHeaderLevel","join","convertHeader","orderedList","convertOrderedList","unorderedList","convertUnorderedList","definitionList","convertDefinitionList","listElement","isDefinitionList","termText","term","convertDefinitionItem","convertListItem","paragraph","convertParagraph","convertPreformatted","table","convertTable","tableRow","convertTableRow","tableCell","isHeader","convertTableHeader","convertTableCell","horizontalRule","convertHorizontalRule","inlineContainer","convertInlineContainer","bold","convertBold","italic","convertItalic","underline","convertUnderline","code","convertCode","dashed","convertDashed","link","convertLink","convertQuote","convertExample","convertSrc","convertHTML","convertText","Error","postProcess","escapedText","escapeSpecialChars","makeSubscripts","linkURL","nodes","nodesTexts","nodeText","combineNodesTexts","convertHeaderBlock","headerBlock","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlocks","childNodes","childBlock","nextIndex","convertNodes","getNodeTextContent","map","urlPattern","self","replace","matched","makeLink","url","makeSubscript","match","body","subscript","stripParametersFromURL","imageExtensionPattern","RegExp","ConverterHTML","convert","__proto__","title","titleHTML","tag","Math","max","Number","contentHTML","tocHTML","tocToHTML","toString","tocToHTMLFunction","tocList","html","tocItem","sectionNumber","num","inlineTag","headerLink","href","subList","call","attributesNode","previousSibling","attributesText","directiveRawValue","orgClassName","className","orgId","id","headerAttributes","substring","definition","listItemAttributes","listItemText","exec","$2","checkboxAttributes","$1","style","srcParameterStripped","src","imgText","alt","codeLanguage","directiveArguments","textNode","index","contents","blockContent","childBlockContent","block","idx","contentsText","replaceMap","replaceRegexp","Object","keys","predicate","currentText","fromLineNumber","decodeURIComponent","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","name","innerText","auxAttributesText","htmlString","Syntax","rules","define","syntax","toUpperCase","line","Token","Lexer","stream","tokenStack","isListElement","tokens","orderedListElement","unorderedListElement","isTableElement","tableSeparator","tokenize","token","lineNumber","indentation","content","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","blank","isHorizontalRule","isDirective","directiveTypeString","test","beginDirective","endDirective","oneshotDirective","isComment","comment","isLine","pushToken","pushDummyTokenByType","peekStackedToken","getStackedToken","pop","peekNextToken","peekNextLine","getNextToken","getNextLine","hasNext","getLineNumber","forEach","tokenName","PrototypeNode","len","appendChild","newChild","lastChild","string","child","split","methodName","postProcessGiven","Stream","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","parser","initStatus","parseNodes","lexer","multilineCell","key","document","directiveValues","ConverterClass","parse","parseDocument","createErrorReport","message","skipBlank","blankToken","setNodeOriginFromToken","appendNode","newNode","parseTitle","element","parseElement","createTextNode","parseHeader","parsePreformatted","parseList","parseText","parseTable","parseParagraph","createHorizontalRule","parseDirective","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","headerToken","preformattedFirstToken","createPreformatted","textContents","definitionPattern","list","rootToken","createDefinitionList","createUnorderedList","createOrderedList","nextToken","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","createListElement","notBlankNextToken","createTable","sawSeparator","allowMultilineCell","parseTableRow","cell","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","interpretDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","createDirective","toLowerCase","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","verbatim","textContent","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","createParagraph","noEmphasis","lineToken","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","createLink","createBold","createItalic","createUnderline","createCode","createDashed","sequence","sequences","totalLines"],"mappings":"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","file":"js/org.b0aa3dbbf3faa5cf8a6d.js","sourcesContent":["if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n"],"sourceRoot":""}