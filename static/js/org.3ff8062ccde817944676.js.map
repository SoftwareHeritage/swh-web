{"version":3,"file":"js/org.3ff8062ccde817944676.js","mappings":"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","sources":["webpack://swh/./node_modules/org/lib/org.js","webpack://swh/./node_modules/org/lib/org/converter/converter.js","webpack://swh/./node_modules/org/lib/org/converter/html.js","webpack://swh/./node_modules/org/lib/org/lexer.js","webpack://swh/./node_modules/org/lib/org/node.js","webpack://swh/./node_modules/org/lib/org/parser.js","webpack://swh/./node_modules/org/lib/org/stream.js"],"sourcesContent":["if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n"],"names":["exportModule","module","exportedName","hasOwnProperty","exports","Node","Converter","prototype","exportOptions","headerOffset","exportFromLineNumber","suppressSubScriptHandling","suppressAutoLink","translateSymbolArrow","suppressCheckboxHandling","customDirectiveHandler","htmlClassPrefix","htmlIdPrefix","untitled","result","initialize","orgDocument","this","documentOptions","options","headers","sectionNumbers","createTocItem","headerNode","parentTocs","childTocs","parent","computeToc","exportTocLevel","Infinity","toc","previousLevel","currentTocs","i","length","level","levelDiff","j","dummyHeader","createHeader","sectionNumberText","push","k","convertNode","node","recordHeader","insideCodeElement","type","types","directive","directiveName","preformatted","createText","value","text","childText","children","convertNodesInternal","auxData","computeAuxDataForNode","header","taskStatus","indexOf","thisHeaderLevel","previousHeaderLevel","join","convertHeader","orderedList","convertOrderedList","unorderedList","convertUnorderedList","definitionList","convertDefinitionList","listElement","isDefinitionList","termText","term","convertDefinitionItem","convertListItem","paragraph","convertParagraph","convertPreformatted","table","convertTable","tableRow","convertTableRow","tableCell","isHeader","convertTableHeader","convertTableCell","horizontalRule","convertHorizontalRule","inlineContainer","convertInlineContainer","bold","convertBold","italic","convertItalic","underline","convertUnderline","code","convertCode","dashed","convertDashed","link","convertLink","convertQuote","convertExample","convertSrc","convertHTML","convertText","Error","postProcess","escapedText","escapeSpecialChars","makeSubscripts","linkURL","nodes","nodesTexts","nodeText","combineNodesTexts","convertHeaderBlock","headerBlock","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlocks","childNodes","childBlock","nextIndex","convertNodes","getNodeTextContent","map","urlPattern","self","replace","matched","makeLink","url","makeSubscript","match","body","subscript","stripParametersFromURL","imageExtensionPattern","RegExp","ConverterHTML","convert","__proto__","title","titleHTML","tag","Math","max","Number","contentHTML","tocHTML","tocToHTML","toString","tocToHTMLFunction","tocList","html","tocItem","sectionNumber","num","inlineTag","headerLink","href","subList","call","attributesNode","previousSibling","attributesText","directiveRawValue","orgClassName","className","orgId","id","headerAttributes","substring","definition","listItemAttributes","listItemText","exec","$2","checkboxAttributes","$1","style","srcParameterStripped","src","imgText","alt","codeLanguage","directiveArguments","textNode","index","contents","blockContent","childBlockContent","block","idx","contentsText","replaceMap","replaceRegexp","Object","keys","predicate","currentText","fromLineNumber","decodeURIComponent","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","name","innerText","auxAttributesText","htmlString","Syntax","rules","define","syntax","toUpperCase","line","Token","Lexer","stream","tokenStack","isListElement","tokens","orderedListElement","unorderedListElement","isTableElement","tableSeparator","tokenize","token","lineNumber","indentation","content","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","blank","isHorizontalRule","isDirective","directiveTypeString","test","beginDirective","endDirective","oneshotDirective","isComment","comment","isLine","pushToken","pushDummyTokenByType","peekStackedToken","getStackedToken","pop","peekNextToken","peekNextLine","getNextToken","getNextLine","hasNext","getLineNumber","forEach","tokenName","PrototypeNode","len","appendChild","firstChild","lastChild","newChild","string","child","split","methodName","postProcessGiven","Stream","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","parser","initStatus","parseNodes","lexer","multilineCell","key","document","directiveValues","ConverterClass","parse","parseDocument","createErrorReport","message","skipBlank","blankToken","setNodeOriginFromToken","appendNode","newNode","parseTitle","element","parseElement","createTextNode","parseHeader","parsePreformatted","parseList","parseText","parseTable","parseParagraph","createHorizontalRule","parseDirective","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","headerToken","preformattedFirstToken","createPreformatted","textContents","definitionPattern","list","rootToken","createDefinitionList","createUnorderedList","createOrderedList","nextToken","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","createListElement","notBlankNextToken","createTable","sawSeparator","allowMultilineCell","parseTableRow","cell","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","interpretDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","createDirective","toLowerCase","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","verbatim","textContent","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","createParagraph","noEmphasis","lineToken","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","createLink","createBold","createItalic","createUnderline","createCode","createDashed","sequence","sequences","totalLines"],"sourceRoot":""}