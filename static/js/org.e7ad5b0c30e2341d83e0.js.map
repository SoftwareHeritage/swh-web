{"version":3,"sources":["webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js","webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js"],"names":["Converter","Node","ConverterHTML","orgDocument","exportOptions","this","initialize","result","convert","prototype","__proto__","title","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","nodes","toc","computeToc","documentOptions","tocHTML","tocToHTML","toString","tocToHTMLFunction","tocList","html","i","length","tocItem","sectionNumberText","headerNode","sectionNumber","num","inlineTag","header","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","node","parent","type","types","inlineContainer","attributesNode","previousSibling","attributesText","directive","directiveName","directiveRawValue","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","substring","level","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","term","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","exec","RegExp","$2","checkboxAttributes","$1","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","src","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","directiveArguments","convertHTML","children","map","textNode","value","join","convertHeaderBlock","headerBlock","index","contents","push","blockContent","childNodes","childBlockContent","childBlocks","block","idx","contentsText","replaceMap","text","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","matched","Error","predicate","postProcess","currentText","exportFromLineNumber","fromLineNumber","makeLink","url","decodeURIComponent","makeSubscript","match","body","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","hasOwnProperty","attributeValue","name","innerText","auxAttributesText","htmlString","exports","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","options","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","createHeader","k","recordHeader","preformatted","createText","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","listElement","isDefinitionList","termText","paragraph","table","tableRow","tableCell","isHeader","horizontalRule","bold","italic","underline","code","dashed","link","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern","PrototypeNode","len","appendChild","newChild","lastChild","string","child","split","line","define","methodName","toUpperCase","postProcessGiven","exportModule","module","exportedName","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","lexer","multilineCell","key","document","directiveValues","ConverterClass","parse","parseDocument","createErrorReport","message","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","appendNode","newNode","parseTitle","hasNext","element","parseElement","createTextNode","content","pushDummyTokenByType","parseHeader","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableSeparator","parseTable","parseParagraph","createHorizontalRule","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","createListElement","notBlankNextToken","pushToken","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","createDirective","toLowerCase","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","createParagraph","noEmphasis","lineToken","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","createLink","createBold","createItalic","createUnderline","createCode","createDashed","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName"],"mappings":"qGAAA,IAAIA,EAAY,EAAQ,MAAkBA,UACtCC,EAAO,EAAQ,KAAcA,KAEjC,SAASC,EAAcC,EAAaC,GAClCC,KAAKC,WAAWH,EAAaC,GAC7BC,KAAKE,OAASF,KAAKG,UAGrBN,EAAcO,UAAY,CACxBC,UAAWV,EAAUS,UAErBD,QAAS,WACP,IAAIG,EAAQN,KAAKF,YAAYQ,MAAQN,KAAKO,YAAYP,KAAKF,YAAYQ,OAASN,KAAKQ,SACjFC,EAAYT,KAAKU,IAAI,IAAMC,KAAKC,IAAIC,OAAOb,KAAKc,cAAe,GAAIR,GACnES,EAAcf,KAAKgB,aAAahB,KAAKF,YAAYmB,OAAO,GACxDC,EAAMlB,KAAKmB,WAAWnB,KAAKoB,gBAAqB,KAChDC,EAAUrB,KAAKsB,UAAUJ,GAE7B,MAAO,CACLZ,MAAOA,EACPG,UAAWA,EACXM,YAAaA,EACbM,QAASA,EACTH,IAAKA,EACLK,SAAU,WACR,OAAOd,EAAYY,EAAU,KAAON,KAK1CO,UAAW,SAAUJ,GAoBnB,OAnBA,SAASM,EAAkBC,GAEzB,IADA,IAAIC,EAAO,GACFC,EAAI,EAAGA,EAAIF,EAAQG,SAAUD,EAAG,CACvC,IAAIE,EAAUJ,EAAQE,GAClBG,EAAoBD,EAAQE,WAAWD,kBACvCE,EAAgBhC,KAAKoB,gBAAgBa,IACnCjC,KAAKkC,UAAU,OAAQJ,EAAmB,CACxC,MAAS,mBACN,GACPK,EAASnC,KAAKoC,mBAAmBP,EAAQE,YACzCM,EAAarC,KAAKkC,UAAU,IAAKF,EAAgBG,EAAQ,CAC3DG,KAAM,WAAaR,EAAkBS,QAAQ,MAAO,OAElDC,EAAUX,EAAQY,UAAUb,OAASJ,EAAkBkB,KAAK1C,KAAM6B,EAAQY,WAAa,GAC3Ff,GAAQ1B,KAAKU,IAAI,KAAM2B,EAAaG,GAEtC,OAAOxC,KAAKU,IAAI,KAAMgB,IAGCgB,KAAK1C,KAAMkB,IAGtCyB,sBAAuB,SAAUC,GAC/B,KAAOA,EAAKC,QACLD,EAAKC,OAAOC,OAASlD,EAAKmD,MAAMC,iBACrCJ,EAAOA,EAAKC,OAId,IAFA,IAAII,EAAiBL,EAAKM,gBACtBC,EAAiB,GACdF,GACAA,EAAeH,OAASlD,EAAKmD,MAAMK,WACF,eAAjCH,EAAeI,eACpBF,GAAkBF,EAAeK,kBAAoB,IACrDL,EAAiBA,EAAeC,gBAElC,OAAOC,GAITI,aAAc,SAAUC,GACtB,OAAOxD,KAAKD,cAAc0D,gBACxBzD,KAAKD,cAAc0D,gBAAkBD,EACnCA,GAINE,MAAO,SAAUC,GACf,OAAO3D,KAAKD,cAAc6D,aACxB5D,KAAKD,cAAc6D,aAAeD,EAChCA,GAONE,cAAe,SAAUjB,EAAMkB,EAAWC,EACjBC,EAAYlC,GACnC,IAAImC,EAAmB,GAkBvB,OAhBID,IACFF,EAAY9D,KAAKkC,UAAU,OAAQ4B,EAAUI,UAAU,EAAG,GAAI,CAC5D,MAAS,eAAiBF,IACvBF,EAAUI,UAAU,IAGvBpC,IACFgC,EAAY9D,KAAKkC,UAAU,OAAQJ,EAAmB,CACpD,MAAS,mBACNgC,EACLG,EAAqB,GAAI,UAAYnC,EAAkBS,QAAQ,MAAO,MAGpEyB,IACFC,EAAwB,MAAI,eAAiBD,GAExChE,KAAKU,IAAI,KAAOV,KAAKc,aAAe8B,EAAKuB,OAChCL,EAAWG,EAAkBF,IAG/CK,mBAAoB,SAAUxB,EAAMkB,EAAWC,GAC7C,OAAO/D,KAAKU,IAAI,KAAMoD,EAAW,KAAMC,IAGzCM,qBAAsB,SAAUzB,EAAMkB,EAAWC,GAC/C,OAAO/D,KAAKU,IAAI,KAAMoD,EAAW,KAAMC,IAGzCO,sBAAuB,SAAU1B,EAAMkB,EAAWC,GAChD,OAAO/D,KAAKU,IAAI,KAAMoD,EAAW,KAAMC,IAGzCQ,sBAAuB,SAAU3B,EAAMkB,EAAWC,EACjBS,EAAMC,GACrC,OAAOzE,KAAKU,IAAI,KAAM8D,GAAQxE,KAAKU,IAAI,KAAM+D,IAG/CC,gBAAiB,SAAU9B,EAAMkB,EAAWC,GAC1C,GAAI/D,KAAKD,cAAc4E,yBACrB,OAAO3E,KAAKU,IAAI,KAAMoD,EAAW,KAAMC,GAEvC,IAAIa,EAAqB,GACrBC,EAAef,EAEnB,GAAI,2BAA2BgB,KAAKD,GAAe,CACjDA,EAAeE,OAAOC,GACtB,IAEIC,EAAqB,CAAEnC,KAAM,YACjC,OAHwBiC,OAAOG,IAI/B,IAAK,IACHD,EAA4B,QAAI,OAChCL,EAAmB,wBAA0B,OAC7C,MACF,IAAK,IACHA,EAAmB,wBAA0B,eAC7C,MACF,QACEA,EAAmB,wBAA0B,SAI/CC,EAAe7E,KAAKkC,UAAU,QAAS,KAAM+C,GAAsBJ,EAGrE,OAAO7E,KAAKU,IAAI,KAAMmE,EAAcD,EAAoBb,IAI5DoB,iBAAkB,SAAUvC,EAAMkB,EAAWC,GAC3C,OAAO/D,KAAKU,IAAI,IAAKoD,EAAW,KAAMC,IAGxCqB,oBAAqB,SAAUxC,EAAMkB,EAAWC,GAC9C,OAAO/D,KAAKU,IAAI,MAAOoD,EAAW,KAAMC,IAG1CsB,aAAc,SAAUzC,EAAMkB,EAAWC,GACvC,OAAO/D,KAAKU,IAAI,QAASV,KAAKU,IAAI,QAASoD,GAAY,KAAMC,IAG/DuB,gBAAiB,SAAU1C,EAAMkB,EAAWC,GAC1C,OAAO/D,KAAKU,IAAI,KAAMoD,IAGxByB,mBAAoB,SAAU3C,EAAMkB,EAAWC,GAC7C,OAAO/D,KAAKU,IAAI,KAAMoD,IAGxB0B,iBAAkB,SAAU5C,EAAMkB,EAAWC,GAC3C,OAAO/D,KAAKU,IAAI,KAAMoD,IAGxB2B,sBAAuB,SAAU7C,EAAMkB,EAAWC,GAChD,OAAO/D,KAAKU,IAAI,KAAM,KAAM,KAAMqD,IAGpC2B,uBAAwB,SAAU9C,EAAMkB,EAAWC,GACjD,OAAOD,GAGT6B,YAAa,SAAU/C,EAAMkB,EAAWC,GACtC,OAAO/D,KAAKkC,UAAU,IAAK4B,IAG7B8B,cAAe,SAAUhD,EAAMkB,EAAWC,GACxC,OAAO/D,KAAKkC,UAAU,IAAK4B,IAG7B+B,iBAAkB,SAAUjD,EAAMkB,EAAWC,GAC3C,OAAO/D,KAAKkC,UAAU,OAAQ4B,EAAW,CACvCgC,MAAO,gCAIXC,YAAa,SAAUnD,EAAMkB,EAAWC,GACtC,OAAO/D,KAAKkC,UAAU,OAAQ4B,IAGhCkC,cAAe,SAAUpD,EAAMkB,EAAWC,GACxC,OAAO/D,KAAKkC,UAAU,MAAO4B,IAG/BmC,YAAa,SAAUrD,EAAMkB,EAAWC,GACtC,IAAImC,EAAuBlG,KAAKmG,uBAAuBvD,EAAKwD,KAC5D,GAAIpG,KAAKqG,sBAAsBvB,KAAKoB,GAAuB,CACzD,IAAII,EAAUtG,KAAKoC,mBAAmBQ,GACtC,OAAO5C,KAAKkC,UAAU,MAAO,KAAM,CACjCkE,IAAKxD,EAAKwD,IACVG,IAAKD,EACLhG,MAAOgG,GACNvC,GAEH,OAAO/D,KAAKkC,UAAU,IAAK4B,EAAW,CAAExB,KAAMM,EAAKwD,OAIvDI,aAAc,SAAU5D,EAAMkB,EAAWC,GACvC,OAAO/D,KAAKU,IAAI,aAAcoD,EAAW,KAAMC,IAGjD0C,eAAgB,SAAU7D,EAAMkB,EAAWC,GACzC,OAAO/D,KAAKU,IAAI,MAAOoD,EAAW,KAAMC,IAG1C2C,WAAY,SAAU9D,EAAMkB,EAAWC,GACrC,IAAI4C,EAAe/D,EAAKgE,mBAAmBhF,OACnCgB,EAAKgE,mBAAmB,GACxB,UAIR,OAHA9C,EAAY9D,KAAKU,IAAI,OAAQoD,EAAW,CACtC,MAAS,YAAc6C,GACtB5C,GACI/D,KAAKU,IAAI,MAAOoD,EAAW,CAChC,MAAS,iBAKb+C,YAAa,SAAUjE,EAAMkB,EAAWC,GACtC,MAA2B,UAAvBnB,EAAKS,cACAT,EAAKU,kBACoB,SAAvBV,EAAKS,cACPT,EAAKkE,SAASC,KAAI,SAAUC,GACjC,OAAOA,EAASC,SACfC,KAAK,MAEDpD,GAKXqD,mBAAoB,SAAUC,EAAajD,EAAOkD,GAChDlD,EAAQA,GAAS,EACjBkD,EAAQA,GAAS,EAEjB,IAAIC,EAAW,GAEXvF,EAAaqF,EAAYjF,OACzBJ,GACFuF,EAASC,KAAKvH,KAAKO,YAAYwB,IAGjC,IAAIyF,EAAexH,KAAKgB,aAAaoG,EAAYK,YACjDH,EAASC,KAAKC,GAEd,IAAIE,EAAoBN,EAAYO,YAC7BZ,KAAI,SAAUa,EAAOC,GACpB,OAAO7H,KAAKmH,mBAAmBS,EAAOzD,EAAQ,EAAG0D,KAChD7H,MACFkH,KAAK,MACZI,EAASC,KAAKG,GAEd,IAAII,EAAeR,EAASJ,KAAK,MAEjC,OAAInF,EACK/B,KAAKU,IAAI,UAAW,KAAO4G,EAASJ,KAAK,MAAO,CACrD,MAAS,qBAAuB/C,IAG3B2D,GAQXC,WAAY,CAEV,IAAK,CAAC,QAAS,MACf,IAAK,CAAC,QAAS,MACf,IAAK,CAAC,QAAS,MACf,IAAK,CAAC,QAAS,MACf,IAAK,CAAC,QAAS,MACf,KAAM,CAAC,WAAY,SAAUC,EAAMC,GACjC,OAAOjI,KAAKD,cAAcmI,uBAAyBD,KAIvDE,cAAe,KAGfC,mBAAoB,SAAUJ,EAAMC,GAC7BjI,KAAKmI,gBACRnI,KAAKmI,cAAgB,IAAIpD,OAAOsD,OAAOC,KAAKtI,KAAK+H,YAAYb,KAAK,KAAM,MAG1E,IAAIa,EAAa/H,KAAK+H,WAClBQ,EAAOvI,KACX,OAAOgI,EAAKzF,QAAQvC,KAAKmI,eAAe,SAAUK,GAChD,IAAKT,EAAWS,GACd,MAAMC,MAAM,qCAGd,IAAIC,EAAYX,EAAWS,GAAS,GACpC,MAAyB,mBAAdE,GACNA,EAAUhG,KAAK6F,EAAMP,EAAMC,GAKzBF,EAAWS,GAAS,GAHlBA,MAQbG,YAAa,SAAU/F,EAAMgG,EAAaX,GAQxC,OAPIjI,KAAKD,cAAc8I,sBACY,iBAAxBjG,EAAKkG,iBAEdF,EAAc5I,KAAKkC,UAAU,MAAO0G,EAAa,CAC/C,mBAAoBhG,EAAKkG,kBAGtBF,GAITG,SAAU,SAAUC,GAClB,MAAO,YAAeA,EAAM,KAAQC,mBAAmBD,GAAO,QAIhEE,cAAe,SAAUC,EAAOC,EAAMC,GACpC,MAAO,sCACLD,EACA,4CACAC,EACA,WAOJC,yBAA0B,SAAUC,GAClC,IAAIC,EAAmB,GACvB,IAAK,IAAIC,KAAiBF,EACxB,GAAIA,EAAiBG,eAAeD,GAAgB,CAClD,IAAIE,EAAiBJ,EAAiBE,GAIhB,UAAlBA,EACFE,EAAiB3J,KAAKuD,aAAaoG,GACR,OAAlBF,IACTE,EAAiB3J,KAAK0D,MAAMiG,IAE9BH,GAAoB,IAAMC,EAAgB,KAAQE,EAAiB,IAGvE,OAAOH,GAGTtH,UAAW,SAAU0H,EAAMC,EAAWN,EAAkBO,GACtDP,EAAmBA,GAAoB,GAEvC,IAAIQ,EAAa,IAAMH,EAMvB,OAJIE,IACFC,GAAc,IAAMD,GACtBC,GAAc/J,KAAKsJ,yBAAyBC,GAE1B,OAAdM,EACKE,EAAa,KAEtBA,GAAc,IAAMF,EAAY,KAAOD,EAAO,KAKhDlJ,IAAK,SAAUkJ,EAAMC,EAAWN,EAAkBO,GAChD,OAAO9J,KAAKkC,UAAU0H,EAAMC,EAAWN,EAAkBO,GAAqB,OAKhFE,EAAQnK,cAAgBA,G,qBCxZ1B,IAAID,EAAO,EAAQ,KAAcA,KAEjC,SAASD,KAGTA,EAAUS,UAAY,CACpBL,cAAe,CACbe,aAAc,EACd+H,sBAAsB,EACtBoB,2BAA2B,EAC3BC,kBAAkB,EAElBhC,sBAAsB,EACtBvD,0BAA0B,EAE1BwF,uBAAwB,KAExB1G,gBAAiB,KACjBG,aAAc,MAGhBpD,SAAU,WACVN,OAAQ,KAIRD,WAAY,SAAUH,EAAaC,GACjCC,KAAKF,YAAcA,EACnBE,KAAKoB,gBAAkBtB,EAAYsK,SAAW,GAC9CpK,KAAKD,cAAgBA,GAAiB,GAEtCC,KAAKqK,QAAU,GACfrK,KAAKc,aACwC,iBAApCd,KAAKD,cAAce,aAA4Bd,KAAKD,cAAce,aAAe,EAC1Fd,KAAKsK,eAAiB,CAAC,IAGzBC,cAAe,SAAUxI,EAAYyI,GACnC,IAAI/H,EAAY,GAGhB,OAFAA,EAAUI,OAAS2H,EACL,CAAEzI,WAAYA,EAAYU,UAAWA,IAIrDtB,WAAY,SAAUsJ,GACU,iBAAnBA,IACTA,EAAiBC,KAEnB,IAAIxJ,EAAM,GACVA,EAAI2B,OAAS,KAKb,IAHA,IAAI8H,EAAgB,EAChBC,EAAc1J,EAETS,EAAI,EAAGA,EAAI3B,KAAKqK,QAAQzI,SAAUD,EAAG,CAC5C,IAAII,EAAa/B,KAAKqK,QAAQ1I,GAE9B,KAAII,EAAWoC,MAAQsG,GAAvB,CAGA,IAAII,EAAY9I,EAAWoC,MAAQwG,EACnC,GAAIE,EAAY,EACd,IAAK,IAAIC,EAAI,EAAGA,EAAID,IAAaC,EAAG,CAClC,GAA2B,IAAvBF,EAAYhJ,OAAc,CAE5B,IAAImJ,EAAcnL,EAAKoL,aAAa,GAAI,CACtC7G,MAAOwG,EAAgBG,IAEzBC,EAAYjJ,kBAAoB,GAChC8I,EAAYrD,KAAKvH,KAAKuK,cAAcQ,EAAaH,IAEnDA,EAAcA,EAAYA,EAAYhJ,OAAS,GAAGa,eAE/C,GAAIoI,EAAY,EAAG,CACxBA,GAAaA,EACb,IAAK,IAAII,EAAI,EAAGA,EAAIJ,IAAaI,EAC/BL,EAAcA,EAAY/H,OAI9B+H,EAAYrD,KAAKvH,KAAKuK,cAAcxI,EAAY6I,IAEhDD,EAAgB5I,EAAWoC,OAG7B,OAAOjD,GAGTX,YAAa,SAAUqC,EAAMsI,EAAcjD,GACpCA,IACCrF,EAAKE,OAASlD,EAAKmD,MAAMK,UACA,YAAvBR,EAAKS,eACkB,QAAvBT,EAAKS,gBACP4E,GAAoB,GAEbrF,EAAKE,OAASlD,EAAKmD,MAAMoI,eAClClD,GAAoB,IAIJ,iBAATrF,IACTA,EAAOhD,EAAKwL,WAAW,KAAM,CAAEnE,MAAOrE,KAGxC,IACIoF,EADAlE,EAAYlB,EAAKkE,SAAW9G,KAAKqL,qBAAqBzI,EAAKkE,SAAUoE,EAAcjD,GAAqB,GAGxGlE,EAAU/D,KAAK2C,sBAAsBC,GAEzC,OAAQA,EAAKE,MACb,KAAKlD,EAAKmD,MAAMZ,OAEd,IAAI6B,EAAa,KACkB,IAA/BF,EAAUwH,QAAQ,SACpBtH,EAAa,OACyB,IAA/BF,EAAUwH,QAAQ,WACzBtH,EAAa,QAGf,IAAIlC,EAAoB,KACxB,GAAIoJ,EAAc,CAChB,IAAIK,EAAkB3I,EAAKuB,MACvBqH,EAAsBxL,KAAKsK,eAAe1I,OAC9C,GAAI2J,EAAkBC,EAGpB,IADA,IAAIX,EAAYU,EAAkBC,EACzBV,EAAI,EAAGA,EAAID,IAAaC,EAC/B9K,KAAKsK,eAAeiB,EAAkB,EAAIT,GAAK,OAExCS,EAAkBC,IAC3BxL,KAAKsK,eAAe1I,OAAS2J,GAE/BvL,KAAKsK,eAAeiB,EAAkB,KACtCzJ,EAAoB9B,KAAKsK,eAAepD,KAAK,KAC7CtE,EAAKd,kBAAoBA,EAG3BkG,EAAOhI,KAAK6D,cAAcjB,EAAMkB,EAAWC,EACjBC,EAAYlC,GAElCoJ,GACFlL,KAAKqK,QAAQ9C,KAAK3E,GACpB,MACF,KAAKhD,EAAKmD,MAAM0I,YACdzD,EAAOhI,KAAKoE,mBAAmBxB,EAAMkB,EAAWC,GAChD,MACF,KAAKnE,EAAKmD,MAAM2I,cACd1D,EAAOhI,KAAKqE,qBAAqBzB,EAAMkB,EAAWC,GAClD,MACF,KAAKnE,EAAKmD,MAAM4I,eACd3D,EAAOhI,KAAKsE,sBAAsB1B,EAAMkB,EAAWC,GACnD,MACF,KAAKnE,EAAKmD,MAAM6I,YACd,GAAIhJ,EAAKiJ,iBAAkB,CACzB,IAAIC,EAAW9L,KAAKqL,qBAAqBzI,EAAK4B,KAAM0G,EAAcjD,GAClED,EAAOhI,KAAKuE,sBAAsB3B,EAAMkB,EAAWC,EACjB+H,EAAUhI,QAE5CkE,EAAOhI,KAAK0E,gBAAgB9B,EAAMkB,EAAWC,GAE/C,MACF,KAAKnE,EAAKmD,MAAMgJ,UACd/D,EAAOhI,KAAKmF,iBAAiBvC,EAAMkB,EAAWC,GAC9C,MACF,KAAKnE,EAAKmD,MAAMoI,aACdnD,EAAOhI,KAAKoF,oBAAoBxC,EAAMkB,EAAWC,GACjD,MACF,KAAKnE,EAAKmD,MAAMiJ,MACdhE,EAAOhI,KAAKqF,aAAazC,EAAMkB,EAAWC,GAC1C,MACF,KAAKnE,EAAKmD,MAAMkJ,SACdjE,EAAOhI,KAAKsF,gBAAgB1C,EAAMkB,EAAWC,GAC7C,MACF,KAAKnE,EAAKmD,MAAMmJ,UAEZlE,EADEpF,EAAKuJ,SACAnM,KAAKuF,mBAAmB3C,EAAMkB,EAAWC,GAEzC/D,KAAKwF,iBAAiB5C,EAAMkB,EAAWC,GAChD,MACF,KAAKnE,EAAKmD,MAAMqJ,eACdpE,EAAOhI,KAAKyF,sBAAsB7C,EAAMkB,EAAWC,GACnD,MAIF,KAAKnE,EAAKmD,MAAMC,gBACdgF,EAAOhI,KAAK0F,uBAAuB9C,EAAMkB,EAAWC,GACpD,MACF,KAAKnE,EAAKmD,MAAMsJ,KACdrE,EAAOhI,KAAK2F,YAAY/C,EAAMkB,EAAWC,GACzC,MACF,KAAKnE,EAAKmD,MAAMuJ,OACdtE,EAAOhI,KAAK4F,cAAchD,EAAMkB,EAAWC,GAC3C,MACF,KAAKnE,EAAKmD,MAAMwJ,UACdvE,EAAOhI,KAAK6F,iBAAiBjD,EAAMkB,EAAWC,GAC9C,MACF,KAAKnE,EAAKmD,MAAMyJ,KACdxE,EAAOhI,KAAK+F,YAAYnD,EAAMkB,EAAWC,GACzC,MACF,KAAKnE,EAAKmD,MAAM0J,OACdzE,EAAOhI,KAAKgG,cAAcpD,EAAMkB,EAAWC,GAC3C,MACF,KAAKnE,EAAKmD,MAAM2J,KACd1E,EAAOhI,KAAKiG,YAAYrD,EAAMkB,EAAWC,GACzC,MACF,KAAKnE,EAAKmD,MAAMK,UACd,OAAQR,EAAKS,eACb,IAAK,QACH2E,EAAOhI,KAAKwG,aAAa5D,EAAMkB,EAAWC,GAC1C,MACF,IAAK,UACHiE,EAAOhI,KAAKyG,eAAe7D,EAAMkB,EAAWC,GAC5C,MACF,IAAK,MACHiE,EAAOhI,KAAK0G,WAAW9D,EAAMkB,EAAWC,GACxC,MACF,IAAK,OACL,IAAK,QACHiE,EAAOhI,KAAK6G,YAAYjE,EAAMkB,EAAWC,GACzC,MACF,QAGIiE,EAFEhI,KAAKD,cAAcoK,wBACnBnK,KAAKD,cAAcoK,uBAAuBvH,EAAKS,eAC1CrD,KAAKD,cAAcoK,uBAAuBvH,EAAKS,eACpDT,EAAMkB,EAAWC,GAGZD,EAGX,MACF,KAAKlE,EAAKmD,MAAMiF,KACdA,EAAOhI,KAAK2M,YAAY/J,EAAKqE,MAAOgB,GACpC,MACF,QACE,MAAMQ,MAAM,sBAAwB7F,EAAKE,MAO3C,MAJgC,mBAArB9C,KAAK2I,cACdX,EAAOhI,KAAK2I,YAAY/F,EAAMoF,EAAMC,IAG/BD,GAGT2E,YAAa,SAAU3E,EAAMC,GAC3B,IAAI2E,EAAc5M,KAAKoI,mBAAmBJ,EAAMC,GAShD,OAPKjI,KAAKD,cAAckK,2BAA8BhC,IACpD2E,EAAc5M,KAAK6M,eAAeD,EAAa3E,IAE5CjI,KAAKD,cAAcmK,mBACtB0C,EAAc5M,KAAK8M,QAAQF,IAGtBA,GAIT/F,YAAa,SAAUjE,EAAMkB,EAAWC,GACtC,OAAOD,GAGTuH,qBAAsB,SAAUpK,EAAOiK,EAAcjD,GAEnD,IADA,IAAI8E,EAAa,GACRpL,EAAI,EAAGA,EAAIV,EAAMW,SAAUD,EAAG,CACrC,IAAIiB,EAAO3B,EAAMU,GACbqL,EAAWhN,KAAKO,YAAYqC,EAAMsI,EAAcjD,GACpD8E,EAAWxF,KAAKyF,GAElB,OAAOhN,KAAKiN,kBAAkBF,IAGhC5F,mBAAoB,SAAUC,EAAa8D,GACzC,MAAMzC,MAAM,0CAGdyE,kBAAmB,SAAUC,EAAYjC,GACvC,OAAOlL,KAAKmH,mBAAmBgG,EAAYjC,IAG7CkC,yBAA0B,SAAUnM,EAAOoM,EAAgBC,GACzD,IAAI3F,EAAc,GACdF,EAAa,QAEa,IAAnB4F,IACTA,EAAiB,QAEQ,IAAhBC,IACTA,EAAc,MAGhB,IAAK,IAAI3L,EAAI0L,EAAgB1L,EAAIV,EAAMW,QAAS,CAC9C,IAAIgB,EAAO3B,EAAMU,GAIjB,GAFeiB,EAAKE,OAASlD,EAAKmD,MAAMZ,OAExC,CAOA,GAAImL,GAAe1K,EAAKuB,OAASmJ,EAAYnJ,MAE3C,MAIA,IAAIoJ,EAAavN,KAAKoN,yBAAyBnM,EAAOU,EAAI,EAAGiB,GAC7D+E,EAAYJ,KAAKgG,GACjB5L,EAAI4L,EAAWC,eAdf/F,EAAWF,KAAK3E,GAChBjB,GAAQ,EAkBZ,MAAO,CACLQ,OAAQmL,EACR7F,WAAYA,EACZ+F,UAAW7L,EACXgG,YAAaA,IAIjB3G,aAAc,SAAUC,EAAOiK,EAAcjD,GAC3C,OAAOjI,KAAKqL,qBAAqBpK,EAAOiK,EAAcjD,IAGxDgF,kBAAmB,SAAUF,GAC3B,OAAOA,EAAW7F,KAAK,KAGzB9E,mBAAoB,SAAUQ,GAC5B,OAAIA,EAAKE,OAASlD,EAAKmD,MAAMiF,KACpBhI,KAAKoI,mBAAmBxF,EAAKqE,OAE7BrE,EAAKkE,SAAWlE,EAAKkE,SAASC,IAAI/G,KAAKoC,mBAAoBpC,MAAMkH,KAAK,IAAM,IAIvFkB,mBAAoB,SAAUJ,GAC5B,MAAMS,MAAM,iCAIdgF,WAAY,uLAGZX,QAAS,SAAU9E,GACjB,IAAIO,EAAOvI,KACX,OAAOgI,EAAKzF,QAAQvC,KAAKyN,YAAY,SAAUjF,GAG7C,OAFIA,EAAQ8C,QAAQ,OAAS,IAC3B9C,EAAU,UAAYA,GACjBD,EAAKQ,SAASP,OAIzBO,SAAU,SAAUC,GAClB,MAAMP,MAAM,uBAGdoE,eAAgB,SAAU7E,GACxB,MAAkC,OAA9BhI,KAAKoB,gBAAgB,KAChB4G,EAAKzF,QAAQ,0BACAvC,KAAKkJ,eAClBlJ,KAAKoB,gBAAgB,KACrB4G,EAAKzF,QAAQ,0BACAvC,KAAKkJ,eAElBlB,GAGXkB,cAAe,SAAUC,EAAOC,EAAMC,GACpC,MAAMZ,MAAM,4BAGdtC,uBAAwB,SAAU6C,GAChC,OAAOA,EAAIzG,QAAQ,QAAS,KAG9B8D,sBAAuB,IAAItB,OAAO,IAAM,CACtC,MAAO,MAAO,OAAQ,MAAO,MAAO,OACpC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAC1CmC,KAAK,KAAO,KAAM,MAIpB8C,EAAQrK,UAAYA,G,iCCrYtB,8G,oBCAA,SAAS+N,EAAc5K,EAAMgE,GAI3B,GAHA9G,KAAK8C,KAAOA,EACZ9C,KAAK8G,SAAW,GAEZA,EACF,IAAK,IAAInF,EAAI,EAAGgM,EAAM7G,EAASlF,OAAQD,EAAIgM,IAAOhM,EAChD3B,KAAK4N,YAAY9G,EAASnF,IAIhC+L,EAActN,UAAY,CACxB8C,gBAAiB,KACjBL,OAAQ,KACR,iBACE,OAAO7C,KAAK8G,SAASlF,OAAS,EAC5B,KAAO5B,KAAK8G,SAAS,IAEzB,gBACE,OAAO9G,KAAK8G,SAASlF,OAAS,EAC5B,KAAO5B,KAAK8G,SAAS9G,KAAK8G,SAASlF,OAAS,IAEhDgM,YAAa,SAAUC,GACrB,IAAI3K,EAAkBlD,KAAK8G,SAASlF,OAAS,EACvC,KAAO5B,KAAK8N,UAClB9N,KAAK8G,SAASS,KAAKsG,GACnBA,EAAS3K,gBAAkBA,EAC3B2K,EAAShL,OAAS7C,MAEpBuB,SAAU,WACR,IAAIwM,EAAS,IAAM/N,KAAK8C,KAAO,IAY/B,YAV0B,IAAf9C,KAAKiH,MACd8G,GAAU,IAAM/N,KAAKiH,MACZjH,KAAK8G,WACdiH,GAAU,KAAO/N,KAAK8G,SAASC,KAAI,SAAUiH,EAAOnG,GAClD,MAAO,IAAMA,EAAM,IAAMmG,EAAMzM,cAC9B2F,KAAK,MAAM+G,MAAM,MAAMlH,KAAI,SAAUmH,GACtC,MAAO,KAAOA,KACbhH,KAAK,OAGH6G,IAIX,IAAInO,EAAO,CACTmD,MAAO,GAEPoL,OAAQ,SAAUvE,EAAMjB,GACtB3I,KAAK+C,MAAM6G,GAAQA,EAEnB,IAAIwE,EAAa,SAAWxE,EAAK1F,UAAU,EAAG,GAAGmK,cAAgBzE,EAAK1F,UAAU,GAC5EoK,EAA0C,mBAAhB3F,EAE9B3I,KAAKoO,GAAc,SAAUtH,EAAUsD,GACrC,IAAIxH,EAAO,IAAI8K,EAAc9D,EAAM9C,GAKnC,OAHIwH,GACF3F,EAAY/F,EAAMwH,GAAW,IAExBxH,KAKbhD,EAAKuO,OAAO,QAAQ,SAAUvL,EAAMwH,GAClCxH,EAAKqE,MAAQmD,EAAQnD,SAEvBrH,EAAKuO,OAAO,UAAU,SAAUvL,EAAMwH,GACpCxH,EAAKuB,MAAQiG,EAAQjG,SAEvBvE,EAAKuO,OAAO,eACZvO,EAAKuO,OAAO,iBACZvO,EAAKuO,OAAO,kBACZvO,EAAKuO,OAAO,eACZvO,EAAKuO,OAAO,aACZvO,EAAKuO,OAAO,gBACZvO,EAAKuO,OAAO,SACZvO,EAAKuO,OAAO,YACZvO,EAAKuO,OAAO,aACZvO,EAAKuO,OAAO,kBACZvO,EAAKuO,OAAO,aAGZvO,EAAKuO,OAAO,mBAEZvO,EAAKuO,OAAO,QACZvO,EAAKuO,OAAO,UACZvO,EAAKuO,OAAO,aACZvO,EAAKuO,OAAO,QACZvO,EAAKuO,OAAO,YACZvO,EAAKuO,OAAO,UACZvO,EAAKuO,OAAO,QAAQ,SAAUvL,EAAMwH,GAClCxH,EAAKwD,IAAMgE,EAAQhE,OAInB4D,EAAQpK,KAAOA,G,oBCjGmB,CAClC,SAAS2O,EAAaC,GACpB,IAAK,IAAIC,KAAgBD,EACnBA,EAAO9E,eAAe+E,KACxBzE,EAAQyE,GAAgBD,EAAOC,IAKrCF,EAAa,EAAQ,MACrBA,EAAa,EAAQ,MACrBA,EAAa,EAAQ,MACrBA,EAAa,EAAQ,MACrBA,EAAa,EAAQ,MACrBA,EAAa,EAAQ,S,oBCdvB,IAAIG,EAAS,EAAQ,KAAeA,OAChCC,EAAS,EAAQ,KAAcA,MAC/B/O,EAAS,EAAQ,KAAaA,KAElC,SAASgP,IACP5O,KAAK6O,aAAe,IAAIC,EA2hB1B,SAASA,IACP9O,KAAK+O,YAAkB,YACvB/O,KAAKgP,aAAkB,mBACvBhP,KAAKiP,gBAAkB,cACvBjP,KAAKkP,WAAkB,aACvBlP,KAAKmP,QAAkB,SAEvBnP,KAAKoP,gBAAkBpP,KAAKqP,uBAC5BrP,KAAKsP,YAAc,qCAhiBrBV,EAAOW,YAAc,SAAUC,EAAQpF,GACrC,IAAIqF,EAAS,IAAIb,EAGjB,OAFAa,EAAOC,WAAWF,EAAQpF,GAC1BqF,EAAOE,aACAF,EAAOxO,OAGhB2N,EAAOxO,UAAY,CACjBsP,WAAY,SAAUF,EAAQpF,GAY5B,GAXsB,iBAAXoF,IACTA,EAAS,IAAId,EAAOc,IACtBxP,KAAK4P,MAAQ,IAAIjB,EAAMa,GACvBxP,KAAKiB,MAAQ,GACbjB,KAAKoK,QAAU,CACblJ,KAAK,EACLe,KAAK,EACL,IAAK,KACL4N,eAAe,GAGbzF,GAA8B,iBAAZA,EACpB,IAAK,IAAI0F,KAAO1F,EACdpK,KAAKoK,QAAQ0F,GAAO1F,EAAQ0F,GAGhC9P,KAAK+P,SAAW,CACd3F,QAASpK,KAAKoK,QACd4F,gBAAiB,GACjB7P,QAAS,SAAU8P,EAAgBlQ,GAEjC,OADgB,IAAIkQ,EAAejQ,KAAMD,GACxBG,UAKvBgQ,MAAO,SAAUV,EAAQpF,GAIvB,OAHApK,KAAK0P,WAAWF,EAAQpF,GACxBpK,KAAKmQ,gBACLnQ,KAAK+P,SAAS9O,MAAQjB,KAAKiB,MACpBjB,KAAK+P,UAGdK,kBAAmB,SAAUC,GAC3B,OAAO,IAAI5H,MAAM4H,EAAU,YAAcrQ,KAAK4P,MAAMU,kBAGtDC,UAAW,WAET,IADA,IAAIC,EAAa,KACVxQ,KAAK4P,MAAMa,gBAAgB3N,OAAS6L,EAAM+B,OAAOC,OACtDH,EAAaxQ,KAAK4P,MAAMgB,eAC1B,OAAOJ,GAGTK,uBAAwB,SAAUjO,EAAMkO,GAEtC,OADAlO,EAAKkG,eAAiBgI,EAAMhI,eACrBlG,GAGTmO,WAAY,SAAUC,GACpB,IAAI9N,EAAkBlD,KAAKiB,MAAMW,OAAS,EAAI5B,KAAKiB,MAAMjB,KAAKiB,MAAMW,OAAS,GAAK,KAClF5B,KAAKiB,MAAMsG,KAAKyJ,GAChBA,EAAQ9N,gBAAkBA,GAO5BiN,cAAe,WACbnQ,KAAKiR,aACLjR,KAAK2P,cAGPA,WAAY,WACV,KAAO3P,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIC,EAAUnR,KAAKoR,eACfD,GAASnR,KAAK+Q,WAAWI,KAIjCF,WAAY,WACVjR,KAAKuQ,YAEDvQ,KAAK4P,MAAMsB,WACXlR,KAAK4P,MAAMa,gBAAgB3N,OAAS6L,EAAM+B,OAAOxC,KACnDlO,KAAK+P,SAASzP,MAAQN,KAAKqR,eAAerR,KAAK4P,MAAMgB,eAAeU,SAEpEtR,KAAK+P,SAASzP,MAAQ,KAExBN,KAAK4P,MAAM2B,qBAAqB5C,EAAM+B,OAAOC,QAS/CS,aAAc,WACZ,IAAID,EAAU,KAEd,OAAQnR,KAAK4P,MAAMa,gBAAgB3N,MACnC,KAAK6L,EAAM+B,OAAOvO,OAChBgP,EAAUnR,KAAKwR,cACf,MACF,KAAK7C,EAAM+B,OAAOvF,aAChBgG,EAAUnR,KAAKyR,oBACf,MACF,KAAK9C,EAAM+B,OAAOgB,mBAClB,KAAK/C,EAAM+B,OAAOiB,qBAChBR,EAAUnR,KAAK4R,YACf,MACF,KAAKjD,EAAM+B,OAAOxC,KAChBiD,EAAUnR,KAAK6R,YACf,MACF,KAAKlD,EAAM+B,OAAOzE,SAClB,KAAK0C,EAAM+B,OAAOoB,eAChBX,EAAUnR,KAAK+R,aACf,MACF,KAAKpD,EAAM+B,OAAOC,MAChB3Q,KAAKuQ,YACDvQ,KAAK4P,MAAMsB,YAEXC,EADEnR,KAAK4P,MAAMa,gBAAgB3N,OAAS6L,EAAM+B,OAAOxC,KACzClO,KAAKgS,iBAELhS,KAAKoR,gBAEnB,MACF,KAAKzC,EAAM+B,OAAOtE,eAChBpM,KAAK4P,MAAMgB,eACXO,EAAUvR,EAAKqS,uBACf,MACF,KAAKtD,EAAM+B,OAAOtN,UAChB+N,EAAUnR,KAAKkS,iBACf,MACF,KAAKvD,EAAM+B,OAAOyB,QAEhBnS,KAAK4P,MAAMgB,eACX,MACF,QACE,MAAM5Q,KAAKoQ,kBAAkB,oBAAsBpQ,KAAK4P,MAAMa,gBAAgB3N,MAGhF,OAAOqO,GAGTiB,gCAAiC,WAC/B,IAGE,OADApS,KAAKoR,aAAepR,KAAKqS,oCAClBrS,KAAKoR,eACZ,QACApR,KAAKoR,aAAepR,KAAKsS,uBAI7BD,oCAAqC,WACnC,OAAIrS,KAAK4P,MAAMa,gBAAgB3N,OAAS6L,EAAM+B,OAAOtN,WACjDpD,KAAK4P,MAAMa,gBAAgB8B,aACtB,KAGFvS,KAAKsS,wBAUdd,YAAa,WACX,IAAIgB,EAAcxS,KAAK4P,MAAMgB,eACzBzO,EAASvC,EAAKoL,aAAa,CAC7BhL,KAAKqR,eAAemB,EAAYlB,UAC/B,CAAEnN,MAAOqO,EAAYrO,QAGxB,OAFAnE,KAAK6Q,uBAAuB1O,EAAQqQ,GAE7BrQ,GAUTsP,kBAAmB,WACjB,IAAIgB,EAAyBzS,KAAK4P,MAAMa,gBACpCtF,EAAevL,EAAK8S,mBAAmB,IAC3C1S,KAAK6Q,uBAAuB1F,EAAcsH,GAI1C,IAFA,IAAIE,EAAe,GAEZ3S,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIJ,EAAQ9Q,KAAK4P,MAAMa,gBACvB,GAAIK,EAAMhO,OAAS6L,EAAM+B,OAAOvF,cAC5B2F,EAAM8B,YAAcH,EAAuBG,YAC7C,MACF5S,KAAK4P,MAAMgB,eACX+B,EAAapL,KAAKuJ,EAAMQ,SAK1B,OAFAnG,EAAayC,YAAY5N,KAAKqR,eAAesB,EAAazL,KAAK,OAAO,IAE/DiE,GAYT0H,kBAAmB,mBAEnBjB,UAAW,WACT,IACIkB,EADAC,EAAY/S,KAAK4P,MAAMa,gBAEvB5E,GAAmB,EAWvB,IATI7L,KAAK6S,kBAAkBG,KAAKD,EAAUzB,UACxCwB,EAAOlT,EAAKqT,qBAAqB,IACjCpH,GAAmB,GAEnBiH,EAAOC,EAAUjQ,OAAS6L,EAAM+B,OAAOiB,qBACrC/R,EAAKsT,oBAAoB,IAAMtT,EAAKuT,kBAAkB,IAE1DnT,KAAK6Q,uBAAuBiC,EAAMC,GAE3B/S,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIkC,EAAYpT,KAAK4P,MAAMa,gBAC3B,IAAK2C,EAAUC,iBAAmBD,EAAUR,cAAgBG,EAAUH,YACpE,MACFE,EAAKlF,YAAY5N,KAAKsT,iBAAiBP,EAAUH,YAAa/G,IAGhE,OAAOiH,GAGTS,sBAAuB,MAEvBD,iBAAkB,SAAUE,EAAiB3H,GAC3C,IAAI4H,EAAmBzT,KAAK4P,MAAMgB,eAC9BhF,EAAchM,EAAK8T,kBAAkB,IAKzC,GAJA1T,KAAK6Q,uBAAuBjF,EAAa6H,GAEzC7H,EAAYC,iBAAmBA,EAE3BA,EAAkB,CACpB,IAAI1C,EAAQnJ,KAAK6S,kBAAkB/N,KAAK2O,EAAiBnC,SACzD1F,EAAYpH,KAAO,CACjBxE,KAAKqR,eAAelI,GAASA,EAAM,GAAKA,EAAM,GAAKnJ,KAAKuT,wBAE1D3H,EAAYgC,YAAY5N,KAAKqR,eAAelI,EAAQA,EAAM,GAAKsK,EAAiBnC,eAEhF1F,EAAYgC,YAAY5N,KAAKqR,eAAeoC,EAAiBnC,UAG/D,KAAOtR,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIV,EAAaxQ,KAAKuQ,YACtB,IAAKvQ,KAAK4P,MAAMsB,UACd,MAEF,IAAIyC,EAAoB3T,KAAK4P,MAAMa,gBAGnC,GAFID,IAAemD,EAAkBN,iBACnCrT,KAAK4P,MAAMgE,UAAUpD,GACnBmD,EAAkBf,aAAeY,EACnC,MAEF,IAAIrC,EAAUnR,KAAKoR,eACfD,GACFvF,EAAYgC,YAAYuD,GAG5B,OAAOvF,GAOTmG,WAAY,WACV,IAAIqB,EAAYpT,KAAK4P,MAAMa,gBACvBzE,EAAQpM,EAAKiU,YAAY,IAC7B7T,KAAK6Q,uBAAuB7E,EAAOoH,GAKnC,IAJA,IAAIU,GAAe,EAEfC,EAAqBX,EAAUtQ,OAAS6L,EAAM+B,OAAOoB,gBAAkB9R,KAAKoK,QAAQyF,cAEjF7P,KAAK4P,MAAMsB,YACVkC,EAAYpT,KAAK4P,MAAMa,iBAAiBuD,kBAC9C,GAAIZ,EAAUtQ,OAAS6L,EAAM+B,OAAOzE,SAAU,CAC5C,IAAIA,EAAWjM,KAAKiU,cAAcF,GAClC/H,EAAM4B,YAAY3B,QAGlB6H,GAAe,EACf9T,KAAK4P,MAAMgB,eAUf,OANIkD,GAAgB9H,EAAMlF,SAASlF,QACjCoK,EAAMlF,SAAS,GAAGA,SAASoN,SAAQ,SAAUC,GAC3CA,EAAKhI,UAAW,KAIbH,GAOTiI,cAAe,SAAUF,GAGvB,IAFA,IAAIK,EAAiB,GAEdpU,KAAK4P,MAAMa,gBAAgB3N,OAAS6L,EAAM+B,OAAOzE,WACtDmI,EAAe7M,KAAKvH,KAAK4P,MAAMgB,gBAC1BmD,KAKP,IAAKK,EAAexS,OAClB,MAAM5B,KAAKoQ,kBAAkB,sBAG/B,IAAIiE,EAAqBD,EAAeE,QACpCC,EAAiBF,EAAmB/C,QAAQrD,MAAM,KAEtDmG,EAAeF,SAAQ,SAAUM,GAC/BA,EAASlD,QAAQrD,MAAM,KAAKiG,SAAQ,SAAUO,EAAUC,GACtDH,EAAeG,IAAYH,EAAeG,IAAY,IAAM,KAAOD,QAKvE,IAAIE,EAAaJ,EAAexN,KAE9B,SAAUiB,GACR,OAAOpI,EAAKgV,gBAAgBhG,EAAOW,YAAYvH,MAC9ChI,MAEL,OAAOA,KAAK6Q,uBAAuBjR,EAAKiV,eAAeF,GAAaN,IAOtEnC,eAAgB,WACd,IAAI4C,EAAiB9U,KAAK4P,MAAMgB,eAC5BmE,EAAgB/U,KAAKgV,6BAA6BF,GAEtD,GAAIA,EAAevC,aACjB,MAAMvS,KAAKoQ,kBAAkB,iCAAmC2E,EAAc1R,eAEhF,GAAIyR,EAAeG,iBAEjB,OADAjV,KAAKkV,mBAAmBH,GACjBA,EAGT,IAAKD,EAAeK,eAClB,MAAMnV,KAAKoQ,kBAAkB,qBAAuB2E,EAAc1R,eAIpE,OADA0R,EAAcjO,SAAW,GACrB9G,KAAKoV,oBAAoBL,GACpB/U,KAAKqV,4BAA4BN,GAEjC/U,KAAKsV,oBAAoBP,IAGpCC,6BAA8B,SAAUF,GACtC,IAAItM,EAAU,4BAA4B1D,KAAKgQ,EAAexD,SAE1DyD,EAAgBnV,EAAK2V,gBAAgB,MAOzC,OANAvV,KAAK6Q,uBAAuBkE,EAAeD,GAC3CC,EAAc1R,cAAgBmF,EAAQ,GAAGgN,cACzCT,EAAcnO,mBAAqB5G,KAAKyV,wBAAwBjN,EAAQ,IACxEuM,EAAcW,iBAAmB1V,KAAK2V,sBAAsBnN,EAAQ,IACpEuM,EAAczR,kBAAoBkF,EAAQ,GAEnCuM,GAGTK,oBAAqB,SAAUL,GAC7B,IAAI1R,EAAgB0R,EAAc1R,cAClC,MAAyB,QAAlBA,GAA6C,YAAlBA,GAAiD,SAAlBA,GAGnEiS,oBAAqB,SAAUP,EAAea,GAG5C,IAFA5V,KAAK4P,MAAM2B,qBAAqB5C,EAAM+B,OAAOC,OAEtC3Q,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIkC,EAAYpT,KAAK4P,MAAMa,gBAC3B,GAAI2C,EAAUtQ,OAAS6L,EAAM+B,OAAOtN,WAChCgQ,EAAUb,cACVvS,KAAKgV,6BAA6B5B,GAAW/P,gBAAkB0R,EAAc1R,cAG/E,OADArD,KAAK4P,MAAMgB,eACJmE,EAET,IAAI5D,EAAUnR,KAAKoS,kCACfjB,GACF4D,EAAcnH,YAAYuD,GAG9B,MAAMnR,KAAKoQ,kBAAkB,sBAAwB2E,EAAc1R,gBAGrEgS,4BAA6B,SAAUN,GAGrC,IAFA,IAAIc,EAAc,GAEX7V,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIkC,EAAYpT,KAAK4P,MAAMa,gBAC3B,GAAI2C,EAAUtQ,OAAS6L,EAAM+B,OAAOtN,WAChCgQ,EAAUb,cACVvS,KAAKgV,6BAA6B5B,GAAW/P,gBAAkB0R,EAAc1R,cAG/E,OAFArD,KAAK4P,MAAMgB,eACXmE,EAAcnH,YAAY5N,KAAKqR,eAAewE,EAAY3O,KAAK,OAAO,IAC/D6N,EAETc,EAAYtO,KAAKvH,KAAK4P,MAAMJ,OAAOsG,eAGrC,MAAM9V,KAAKoQ,kBAAkB,sBAAwB2E,EAAc1R,gBAGrEoS,wBAAyB,SAAUM,GACjC,OAAOA,EAAW9H,MAAM,QAAQ+H,QAAO,SAAUC,GAC/C,OAAOA,EAAMrU,QAAuB,MAAbqU,EAAM,OAIjCN,sBAAuB,SAAUI,GAC/B,OAAOA,EAAW9H,MAAM,QAAQ+H,QAAO,SAAUC,GAC/C,OAAOA,EAAMrU,QAAuB,MAAbqU,EAAM,OAIjCf,mBAAoB,SAAUH,GAE5B,OAAQA,EAAc1R,eACtB,IAAK,WACHrD,KAAKkW,yBAAyBnB,GAC9B,MACF,IAAK,SACH/U,KAAK+P,SAASzP,MAAQyU,EAAczR,kBACpC,MACF,IAAK,UACHtD,KAAK+P,SAASoG,OAASpB,EAAczR,kBACrC,MACF,IAAK,SACHtD,KAAK+P,SAASqG,MAAQrB,EAAczR,kBACpC,MACF,QACEtD,KAAK+P,SAASC,gBAAgB+E,EAAc1R,eAAiB0R,EAAczR,oBAK/E4S,yBAA0B,SAAUG,GAClCA,EAAoBzP,mBAAmBsN,SAAQ,SAAUoC,GACvD,IAAIC,EAAOD,EAAWrI,MAAM,KAC5BjO,KAAKoK,QAAQmM,EAAK,IAAMvW,KAAKwW,kBAAkBD,EAAK,MACnDvW,OAGLwW,kBAAmB,SAAUC,GAC3B,OAAQA,GACR,IAAK,IACH,OAAO,EACT,IAAK,MACH,OAAO,EACT,QACE,MAAI,WAAWzD,KAAKyD,GACXC,SAASD,GACXA,IAQXzE,eAAgB,WACd,IAAI2E,EAAsB3W,KAAK4P,MAAMa,gBACjC1E,EAAYnM,EAAKgX,gBAAgB,IACrC5W,KAAK6Q,uBAAuB9E,EAAW4K,GAIvC,IAFA,IAAIhE,EAAe,GAEZ3S,KAAK4P,MAAMsB,WAAW,CAC3B,IAAIkC,EAAYpT,KAAK4P,MAAMa,gBAC3B,GAAI2C,EAAUtQ,OAAS6L,EAAM+B,OAAOxC,MAC7BkF,EAAUR,YAAc+D,EAAoB/D,YACjD,MACF5S,KAAK4P,MAAMgB,eACX+B,EAAapL,KAAK6L,EAAU9B,SAK9B,OAFAvF,EAAU6B,YAAY5N,KAAKqR,eAAesB,EAAazL,KAAK,QAErD6E,GAGT8F,UAAW,SAAUgF,GACnB,IAAIC,EAAY9W,KAAK4P,MAAMgB,eAC3B,OAAO5Q,KAAKqR,eAAeyF,EAAUxF,QAASuF,IAOhDxF,eAAgB,SAAUrJ,EAAM6O,GAC9B,OAAOA,EAAajX,EAAKwL,WAAW,KAAM,CAAEnE,MAAOe,IAC/ChI,KAAK6O,aAAakI,cAAc/O,KAGxC4G,EAAOxO,UAAUkS,qBAAuB1D,EAAOxO,UAAUgR,aAmBzDtC,EAAa1O,UAAY,CACvB2W,cAAe,SAAU/O,GACvB,IAAIoH,EAAkBpP,KAAKoP,gBAC3BA,EAAgB4H,UAAY,EAO5B,IALA,IACI7N,EAEA8N,EAHA/W,EAAS,GAETgX,EAAe,EAGX/N,EAAQiG,EAAgBtK,KAAKkD,IAAQ,CAC3C,IAAImP,EAAShO,EAAM,GACfiO,EAASjO,EAAM,GACfkO,EAASlO,EAAM,GACfC,EAASD,EAAM,GACfmO,EAASnO,EAAM,GAIboO,EAAanI,EAAgB4H,UAAYG,EAAMvV,OAC/C4V,EAAgBxP,EAAK9D,UAAUgT,EAAcK,EAAaH,EAAIxV,QAClEqV,EAAiB7H,EAAgB4H,UACjC9W,EAAOqH,KAAKvH,KAAKyX,UAAUD,IAC3BpI,EAAgB4H,UAAYC,EAG9B,IAAIS,EAAW,CAAC9X,EAAKwL,WAAW,KAAM,CAAEnE,MAAOmC,KAC3CuO,EAAgB3X,KAAK4X,yBAAyBF,EAAUL,GAC5DnX,EAAOqH,KAAKoQ,GAEZT,EAAe9H,EAAgB4H,UAAYM,EAAK1V,OAOlD,OAJkC,IAA9BwN,EAAgB4H,WAChB5H,EAAgB4H,YAAchP,EAAKpG,OAAS,GAC9C1B,EAAOqH,KAAKvH,KAAKyX,UAAUzP,EAAK9D,UAAUgT,KAEtB,IAAlBhX,EAAO0B,OAEF1B,EAAO,GAEPN,EAAKiY,sBAAsB3X,IAItC4X,MAAO,EACPL,UAAW,SAAUzP,GACnB,IAAIsH,EAActP,KAAKsP,YACvBA,EAAY0H,UAAY,EAOxB,IALA,IAAI7N,EAGA8N,EAFA/W,EAAS,GACTgX,EAAe,EAGX/N,EAAQmG,EAAYxK,KAAKkD,IAAQ,CACvC,IAAImP,EAAQhO,EAAM,GACd/C,EAAQ+C,EAAM,GACd7I,EAAQ6I,EAAM,GAGdoO,EAAajI,EAAY0H,UAAYG,EAAMvV,OAC3C4V,EAAgBxP,EAAK9D,UAAUgT,EAAcK,GACjDrX,EAAOqH,KAAK3H,EAAKwL,WAAW,KAAM,CAAEnE,MAAOuQ,KAG3C,IAAI9K,EAAO9M,EAAKmY,WAAW,IAC3BrL,EAAKtG,IAAMA,EACP9F,GACF2W,EAAiB3H,EAAY0H,UAC7BtK,EAAKkB,YAAY5N,KAAK+W,cAAczW,IACpCgP,EAAY0H,UAAYC,GAExBvK,EAAKkB,YAAYhO,EAAKwL,WAAW,KAAM,CAAEnE,MAAOb,KAElDlG,EAAOqH,KAAKmF,GAEZwK,EAAe5H,EAAY0H,UAO7B,OAJ8B,IAA1B1H,EAAY0H,WACZ1H,EAAY0H,YAAchP,EAAKpG,OAAS,GAC1C1B,EAAOqH,KAAK3H,EAAKwL,WAAW,KAAM,CAAEnE,MAAOe,EAAK9D,UAAUgT,MAErDtX,EAAKiY,sBAAsB3X,IAGpC0X,yBAA0B,SAAUzG,EAASkG,GAC3C,OAAQA,GACR,IAAK,IACH,OAAOzX,EAAKoY,WAAW7G,GACzB,IAAK,IACH,OAAOvR,EAAKqY,aAAa9G,GAC3B,IAAK,IACH,OAAOvR,EAAKsY,gBAAgB/G,GAC9B,IAAK,IACL,IAAK,IACH,OAAOvR,EAAKuY,WAAWhH,GACzB,IAAK,IACH,OAAOvR,EAAKwY,aAAajH,KAI7B9B,qBAAsB,WACpB,OAAO,IAAItK,OACT,KAAO/E,KAAK+O,YAAZ,eACS/O,KAAKmP,QADd,QAEUnP,KAAKiP,gBAFf,OAGSjP,KAAKiP,gBAAkB,IAC9BjP,KAAKkP,WACL,KAAOlP,KAAKiP,gBALd,UAOSjP,KAAKgP,aAAc,aAE1B,OAMNhF,EAAQ4E,OAASA,EACjB5E,EAAQ8E,aAAeA,G,oBCpqBzB,SAASJ,EAAO2J,GACdrY,KAAKsY,UAAYD,EAASpK,MAAM,SAChCjO,KAAKuY,WAAavY,KAAKsY,UAAU1W,OACjC5B,KAAKwY,WAAa,EAGpB9J,EAAOtO,UAAUqY,aAAe,WAC9B,OAAOzY,KAAKkR,UAAYlR,KAAKsY,UAAUtY,KAAKwY,YAAc,MAG5D9J,EAAOtO,UAAU0V,YAAc,WAC7B,OAAO9V,KAAKkR,UAAYlR,KAAKsY,UAAUtY,KAAKwY,cAAgB,MAG9D9J,EAAOtO,UAAU8Q,QAAU,WACzB,OAAOlR,KAAKwY,WAAaxY,KAAKuY,YAI9BvO,EAAQ0E,OAASA,G,oBCfnB,IAAIgK,EAAS,CACXC,MAAO,GAEPxK,OAAQ,SAAUvE,EAAMgP,GACtB5Y,KAAK2Y,MAAM/O,GAAQgP,EAEnB5Y,KADiB,KAAO4J,EAAK1F,UAAU,EAAG,GAAGmK,cAAgBzE,EAAK1F,UAAU,IACzD,SAAUgK,GAC3B,OAAOlO,KAAK2Y,MAAM/O,GAAM9E,KAAKoJ,MAqBnC,SAAS2K,KAmBT,SAASlK,EAAMa,GACbxP,KAAKwP,OAASA,EACdxP,KAAK8Y,WAAa,GArCpBJ,EAAOvK,OAAO,SAAU,kBACxBuK,EAAOvK,OAAO,eAAgB,uBAC9BuK,EAAOvK,OAAO,uBAAwB,gCACtCuK,EAAOvK,OAAO,qBAAsB,gCACpCuK,EAAOvK,OAAO,iBAAkB,4BAChCuK,EAAOvK,OAAO,WAAY,qBAC1BuK,EAAOvK,OAAO,QAAS,MACvBuK,EAAOvK,OAAO,iBAAkB,gBAChCuK,EAAOvK,OAAO,YAAa,oCAC3BuK,EAAOvK,OAAO,UAAW,gBACzBuK,EAAOvK,OAAO,OAAQ,eAStB0K,EAAMzY,UAAY,CAChBiT,cAAe,WACb,OAAOrT,KAAK8C,OAAS6L,EAAM+B,OAAOgB,oBAChC1R,KAAK8C,OAAS6L,EAAM+B,OAAOiB,sBAG/BqC,eAAgB,WACd,OAAOhU,KAAK8C,OAAS6L,EAAM+B,OAAOoB,gBAChC9R,KAAK8C,OAAS6L,EAAM+B,OAAOzE,WAajC0C,EAAMvO,UAAY,CAChB2Y,SAAU,SAAU7K,GAClB,IAAI4C,EAAQ,IAAI+H,EAGhB,GAFA/H,EAAMhI,eAAiB9I,KAAKwP,OAAOgJ,WAE/BE,EAAOvM,SAAS+B,GAClB4C,EAAMhO,KAAc6L,EAAM+B,OAAOvO,OACjC2O,EAAM8B,YAAc,EACpB9B,EAAMQ,QAAcvM,OAAOC,GAE3B8L,EAAM3M,MAAcY,OAAOG,GAAGtD,YACzB,GAAI8W,EAAOM,eAAe9K,GAC/B4C,EAAMhO,KAAc6L,EAAM+B,OAAOvF,aACjC2F,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOC,QACtB,GAAI0T,EAAOO,uBAAuB/K,GACvC4C,EAAMhO,KAAc6L,EAAM+B,OAAOiB,qBACjCb,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOC,QACtB,GAAI0T,EAAOQ,qBAAqBhL,GACrC4C,EAAMhO,KAAc6L,EAAM+B,OAAOgB,mBACjCZ,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOoU,GAE3BrI,EAAMsI,OAAcrU,OAAOC,QACtB,GAAI0T,EAAOW,iBAAiBnL,GACjC4C,EAAMhO,KAAc6L,EAAM+B,OAAOoB,eACjChB,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOC,QACtB,GAAI0T,EAAOY,WAAWpL,GAC3B4C,EAAMhO,KAAc6L,EAAM+B,OAAOzE,SACjC6E,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOC,QACtB,GAAI0T,EAAOa,QAAQrL,GACxB4C,EAAMhO,KAAc6L,EAAM+B,OAAOC,MACjCG,EAAM8B,YAAc,EACpB9B,EAAMQ,QAAc,UACf,GAAIoH,EAAOc,iBAAiBtL,GACjC4C,EAAMhO,KAAc6L,EAAM+B,OAAOtE,eACjC0E,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAc,UACf,GAAIoH,EAAOe,YAAYvL,GAAO,CACnC4C,EAAMhO,KAAc6L,EAAM+B,OAAOtN,UACjC0N,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOoU,GAE3B,IAAIO,EAAsB3U,OAAOC,GAC7B,UAAUgO,KAAK0G,GACjB5I,EAAMqE,gBAAiB,EAChB,QAAQnC,KAAK0G,GACpB5I,EAAMyB,cAAe,EAErBzB,EAAMmE,kBAAmB,OACtB,GAAIyD,EAAOiB,UAAUzL,GAC1B4C,EAAMhO,KAAc6L,EAAM+B,OAAOyB,QACjCrB,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOC,OACtB,KAAI0T,EAAOkB,OAAO1L,GAKvB,MAAM,IAAIzF,MAAM,8BAAgCyF,GAJhD4C,EAAMhO,KAAc6L,EAAM+B,OAAOxC,KACjC4C,EAAM8B,YAAc7N,OAAOG,GAAGtD,OAC9BkP,EAAMQ,QAAcvM,OAAOC,GAK7B,OAAO8L,GAGT8C,UAAW,SAAU9C,GACnB9Q,KAAK8Y,WAAWvR,KAAKuJ,IAGvBS,qBAAsB,SAAUzO,GAC9B,IAAIgO,EAAQ,IAAI+H,EAChB/H,EAAMhO,KAAOA,EACb9C,KAAK8Y,WAAWvR,KAAKuJ,IAGvB+I,iBAAkB,WAChB,OAAO7Z,KAAK8Y,WAAWlX,OAAS,EAC9B5B,KAAK8Y,WAAW9Y,KAAK8Y,WAAWlX,OAAS,GAAK,MAGlDkY,gBAAiB,WACf,OAAO9Z,KAAK8Y,WAAWlX,OAAS,EAC9B5B,KAAK8Y,WAAWiB,MAAQ,MAG5BtJ,cAAe,WACb,OAAOzQ,KAAK6Z,oBACV7Z,KAAK+Y,SAAS/Y,KAAKwP,OAAOiJ,iBAG9B7H,aAAc,WACZ,OAAO5Q,KAAK8Z,mBACV9Z,KAAK+Y,SAAS/Y,KAAKwP,OAAOsG,gBAG9B5E,QAAS,WACP,OAAOlR,KAAKwP,OAAO0B,WAGrBZ,cAAe,WACb,OAAOtQ,KAAKwP,OAAOgJ,aAIvB7J,EAAM+B,OAAS,GACf,CACE,SACA,qBACA,uBACA,WACA,iBACA,eACA,OACA,iBACA,QACA,YACA,WACAwD,SAAQ,SAAU8F,EAAWrY,GAC7BgN,EAAM+B,OAAOsJ,GAAarY,KAQ1BqI,EAAQ2E,MAAQA","file":"js/org.e7ad5b0c30e2341d83e0.js","sourcesContent":["var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n"],"sourceRoot":""}