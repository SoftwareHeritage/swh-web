{% load static %}

<div class="panel panel-default" style="overflow-x: auto;">
  <div class="panel-heading">
      <h2>Download content from the Software Heritage Vault</h2>
  </div>
  <div class="panel-body">
    <p>
      This interface enables to track the status of the different Software Heritage
      Vault cooking tasks created while browsing the archive.
    </p>
    <p>
      Once a cooking task is finished, a link will be made available in order to
      download the associated archive.
    </p>
    <button type="button" class="btn btn-md btn-swh" id="vault-remove-tasks">Remove selected tasks</button>
    <div class="table-responsive">
      <table class="table swh-vault-table" id="vault-cooking-tasks">
        <thead>
          <tr>
            <th><input type="checkbox" id="vault-tasks-toggle-selection"/></th>
            <th style="width: 100px">Object type</th>
            <th>Object id</th>
            <th style="width: 350px">Cooking status</th>
            <th style="width: 320px"></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script>
  var cook_dir_url = "{% url 'vault-cook-directory' 'ffff' %}";
  var cook_rev_url = "{% url 'vault-cook-revision_gitfast' 'ffff' %}";
  var browse_dir_url = "{% url 'browse-directory' 'ffff' %}";
  var browse_rev_url = "{% url 'browse-revision' 'ffff' %}";

  var progress = '<div class="progress" style="margin-bottom: 0px;"> \
                    <div class="progress-bar progress-bar-success progress-bar-striped" \
                         role="progressbar" aria-valuenow="100" aria-valuemin="0" \
                         aria-valuemax="100" style="width: 100%;height: 100%;"> \
                    </div> \
                  </div>';

  function update_progress_bar(progress_bar, cooking_task) {
    if (cooking_task.status == 'new') {
      progress_bar.css('background-color', 'rgba(128, 128, 128, 0.5)');
    } else if (cooking_task.status == 'pending') {
      progress_bar.css('background-color', 'rgba(0, 0, 255, 0.5)');
    } else if (cooking_task.status == 'done') {
      progress_bar.css('background-color', 'rgba(0, 255, 0, 0.5)');
    } else if (cooking_task.status == 'failed') {
      progress_bar.css('background-color', 'rgba(255, 0, 0, 0.5)');
      progress_bar.css('background-image', 'none');
    }
    progress_bar.text(cooking_task.progress_message || cooking_task.status);
    if (cooking_task.status == 'new' || cooking_task.status == 'pending') {
      progress_bar.addClass('active');
    } else {
      progress_bar.removeClass('progress-bar-striped');
    }
  }

  function check_vault_cooking_tasks() {
    var vault_cooking_tasks = JSON.parse(localStorage.getItem("swh-vault-cooking-tasks"));
    if (!vault_cooking_tasks || vault_cooking_tasks.length == 0) {
      $('.swh-vault-table tbody tr').remove();
      check_vault_id = setTimeout(check_vault_cooking_tasks, polling_interval);
      return;
    }
    var cooking_urls = [];
    var tasks = {};
    var current_object_ids = [];
    for (var i = 0 ; i < vault_cooking_tasks.length ; ++i) {
      var cooking_task = vault_cooking_tasks[i];
      current_object_ids.push(cooking_task.object_id);
      tasks[cooking_task.object_id] = cooking_task;
      var cooking_url;
      if (cooking_task.object_type == 'directory') {
        cooking_url = cook_dir_url.replace('ffff', cooking_task.object_id);
      } else {
        cooking_url = cook_rev_url.replace('ffff', cooking_task.object_id);
      }
      if (cooking_task.status != 'done' && cooking_task.status != 'failed') {
        cooking_urls.push($.ajax(cooking_url));
      }
    }
    $('.swh-vault-table tbody tr').each(function(i, row) {
      var object_id = $(row).find('.vault-object-id').data('object-id');
      if ($.inArray(object_id, current_object_ids) == -1) {
        $(row).remove();
      }
    });
    $.when.apply($, cooking_urls).then(function() {
      var table = $("#vault-cooking-tasks tbody");
      for (var i = 0 ; i < cooking_urls.length ; ++i) {
        var resp;
        if (cooking_urls.length == 1) {
          resp = arguments[i];
        } else {
          resp = arguments[i][0];
        }
        var cooking_task = tasks[resp.obj_id];
        cooking_task.status = resp.status;
        cooking_task.fetch_url = resp.fetch_url;
        cooking_task.progress_message = resp.progress_message;
      }
      for (var i = 0 ; i < vault_cooking_tasks.length ; ++i) {
        var cooking_task = vault_cooking_tasks[i];

        var row_task = $('#vault-task-' + cooking_task.object_id);

        if (!row_task.length) {

          var browse_url;
          if (cooking_task.object_type == 'directory') {
            browse_url = browse_dir_url.replace('ffff', cooking_task.object_id);
          } else {
            browse_url = browse_rev_url.replace('ffff', cooking_task.object_id);
          }

          var progress_bar = $.parseHTML(progress)[0];
          var progress_bar_content = $(progress_bar).find('.progress-bar');
          update_progress_bar(progress_bar_content, cooking_task);
          var table_row;
          if (cooking_task.object_type == 'directory') {
            table_row = '<tr id="vault-task-' + cooking_task.object_id + '" title="Once downloaded, the directory can be extracted with the ' +
                        'following command:\n\n$ tar xvzf ' + cooking_task.object_id + '.tar.gz">';
          } else {
            table_row = '<tr id="vault-task-' + cooking_task.object_id + '"  title="Once downloaded, the git repository can be imported with the ' +
                        'following commands:\n\n$ git init\n$ zcat ' + cooking_task.object_id + '.gitfast.gz | git fast-import">';
          }
          table_row += '<td><input type="checkbox" class="vault-task-toggle-selection"/></td>';
          if (cooking_task.object_type == 'directory') {
            table_row += '<td><i class="fa fa-folder fa-fw" aria-hidden="true"></i>directory</td>';
          } else {
            table_row += '<td><i class="octicon octicon-git-commit fa-fw"></i>revision</td>';
          }
          table_row += '<td class="vault-object-id" data-object-id="' + cooking_task.object_id + '"><a href="' + browse_url + '">' + cooking_task.object_id + '</a></td>';
          table_row += '<td style="width: 350px">' + progress_bar.outerHTML + '</td>';
          var dl_link = 'Waiting for download link to be available';
          if (cooking_task.status == 'done') {
            dl_link = '<a class="btn btn-md btn-swh" href="' + cooking_task.fetch_url +
                      '"><i class="fa fa-download fa-fw" aria-hidden="true"></i>Download</a>';
          } else if (cooking_task.status == 'failed') {
            dl_link = '';
          }
          table_row += '<td class="vault-dl-link" style="width: 320px">' + dl_link + '</td>';
          table_row += '</tr>';
          table.prepend(table_row);
        } else {
          var progress_bar = row_task.find('.progress-bar');
          update_progress_bar(progress_bar, cooking_task);
          var dl_link = row_task.find('.vault-dl-link');
          var dl_link = row_task.find('.vault-dl-link');
          if (cooking_task.status == 'done') {
            dl_link[0].innerHTML = '<a class="btn btn-md btn-swh" href="' + cooking_task.fetch_url +
                                   '"><i class="fa fa-download fa-fw" aria-hidden="true"></i>Download</a>';
          } else if (cooking_task.status == 'failed') {
            dl_link[0].innerHTML = '';
          }
        }
      }
      localStorage.setItem("swh-vault-cooking-tasks", JSON.stringify(vault_cooking_tasks));
      check_vault_id = setTimeout(check_vault_cooking_tasks, polling_interval);
    });
  }

  $('#vault-tasks-toggle-selection').change(function() {
    $('.vault-task-toggle-selection').prop('checked', this.checked);
  });

  $('#vault-remove-tasks').click(function() {
    clearTimeout(check_vault_id);
    var tasks_to_remove = [];
    $('.swh-vault-table tbody tr').each(function(i, row) {
      var task_selected = $(row).find('.vault-task-toggle-selection').prop('checked');
      if (task_selected) {
        var object_id = $(row).find('.vault-object-id').data('object-id');
        tasks_to_remove.push(object_id);
        $(row).remove();
      }
    });
    var vault_cooking_tasks = JSON.parse(localStorage.getItem("swh-vault-cooking-tasks"));
    vault_cooking_tasks = jQuery.grep(vault_cooking_tasks, function(task) {
      return $.inArray(task.object_id, tasks_to_remove) == -1;
    });
    localStorage.setItem("swh-vault-cooking-tasks", JSON.stringify(vault_cooking_tasks));
    $('#vault-tasks-toggle-selection').prop('checked', false);
    check_vault_id = setTimeout(check_vault_cooking_tasks, polling_interval);
  });

  var polling_interval = 5000;

  var check_vault_id = setTimeout(check_vault_cooking_tasks, polling_interval);

  $(document).on('shown.bs.tab', 'a[data-toggle="tab"]', function (e) {
    if (e.target.text == 'Vault') {
      clearTimeout(check_vault_id);
      check_vault_cooking_tasks();
    }
  });

  window.onfocus = function() {
    clearTimeout(check_vault_id);
    check_vault_cooking_tasks();
  };

</script>