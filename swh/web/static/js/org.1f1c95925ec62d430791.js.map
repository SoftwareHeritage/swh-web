{"version":3,"sources":["webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js","webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js"],"names":["Converter","__webpack_require__","Node","ConverterHTML","orgDocument","exportOptions","this","initialize","result","convert","prototype","__proto__","title","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","nodes","toc","computeToc","documentOptions","tocHTML","tocToHTML","toString","tocToHTMLFunction","tocList","html","i","length","tocItem","sectionNumberText","headerNode","sectionNumber","num","inlineTag","class","header","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","node","parent","type","types","inlineContainer","attributesNode","previousSibling","attributesText","directive","directiveName","directiveRawValue","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","substring","level","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","term","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","exec","RegExp","$2","checkboxAttributes","$1","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","src","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","directiveArguments","convertHTML","children","map","textNode","value","join","convertHeaderBlock","headerBlock","index","contents","push","blockContent","childNodes","childBlockContent","childBlocks","block","idx","contentsText","replaceMap","&","<",">","\"","'","->","text","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","matched","Error","predicate","postProcess","currentText","exportFromLineNumber","fromLineNumber","data-line-number","makeLink","url","decodeURIComponent","makeSubscript","match","body","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","hasOwnProperty","attributeValue","name","innerText","auxAttributesText","htmlString","exports","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","options","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","createHeader","k","recordHeader","preformatted","createText","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","listElement","isDefinitionList","termText","paragraph","table","tableRow","tableCell","isHeader","horizontalRule","bold","italic","underline","code","dashed","link","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern","r","__webpack_exports__","org__WEBPACK_IMPORTED_MODULE_1__","__WEBPACK_IMPORT_KEY__","key","d","PrototypeNode","len","appendChild","firstChild","lastChild","newChild","string","child","split","line","define","methodName","toUpperCase","postProcessGiven","exportModule","module","exportedName","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","lexer","^","multilineCell","document","directiveValues","ConverterClass","parse","parseDocument","createErrorReport","message","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","appendNode","newNode","parseTitle","hasNext","element","parseElement","createTextNode","content","pushDummyTokenByType","parseHeader","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableSeparator","parseTable","parseParagraph","createHorizontalRule","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","createListElement","notBlankNextToken","pushToken","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","createDirective","toLowerCase","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","createParagraph","noEmphasis","lineToken","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","createLink","createBold","createItalic","createUnderline","createCode","createDashed","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName"],"mappings":"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","file":"js/org.1f1c95925ec62d430791.js","sourcesContent":["var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n"],"sourceRoot":""}