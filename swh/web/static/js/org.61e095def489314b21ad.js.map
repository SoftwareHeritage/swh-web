{"version":3,"sources":["webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js","webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js"],"names":["__webpack_require__","r","__webpack_exports__","org__WEBPACK_IMPORTED_MODULE_1__","__WEBPACK_IMPORT_KEY__","key","d","PrototypeNode","type","children","this","i","len","length","appendChild","prototype","previousSibling","parent","firstChild","lastChild","newChild","push","toString","string","value","map","child","idx","join","split","line","Node","types","define","name","postProcess","methodName","substring","toUpperCase","postProcessGiven","options","node","level","src","exports","exportModule","module","exportedName","hasOwnProperty","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","nodes","lexer","toc","num","^","multilineCell","document","directiveValues","convert","ConverterClass","exportOptions","result","parse","parseDocument","createErrorReport","message","Error","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","fromLineNumber","appendNode","newNode","parseTitle","hasNext","element","parseElement","title","createTextNode","content","pushDummyTokenByType","header","parseHeader","preformatted","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableRow","tableSeparator","parseTable","parseParagraph","horizontalRule","createHorizontalRule","directive","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","createHeader","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","isDefinitionList","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","listElement","createListElement","match","exec","term","notBlankNextToken","pushToken","table","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","isHeader","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","text","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","directiveName","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","matched","createDirective","toLowerCase","directiveArguments","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","directiveRawValue","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","paragraph","createParagraph","noEmphasis","lineToken","createText","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","body","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","link","createLink","createBold","createItalic","createUnderline","createCode","createDashed","RegExp","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","$2","$1","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName","Converter","ConverterHTML","orgDocument","initialize","__proto__","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","computeToc","documentOptions","tocHTML","tocToHTML","tocToHTMLFunction","tocList","html","tocItem","sectionNumberText","headerNode","sectionNumber","inlineTag","class","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","inlineContainer","attributesNode","attributesText","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","checkboxAttributes","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","convertHTML","textNode","convertHeaderBlock","headerBlock","index","contents","blockContent","childNodes","childBlockContent","childBlocks","block","contentsText","replaceMap","&","<",">","\"","'","->","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","predicate","currentText","exportFromLineNumber","data-line-number","makeLink","url","decodeURIComponent","makeSubscript","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","innerText","auxAttributesText","htmlString","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","k","recordHeader","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","termText","tableCell","bold","italic","underline","code","dashed","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern"],"mappings":"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","file":"js/org.61e095def489314b21ad.js","sourcesContent":["/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n"],"sourceRoot":""}