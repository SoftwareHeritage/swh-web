{"version":3,"sources":["webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js","webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js"],"names":["__webpack_require__","r","__webpack_exports__","org__WEBPACK_IMPORTED_MODULE_1__","__WEBPACK_IMPORT_KEY__","key","d","PrototypeNode","type","children","this","i","len","length","appendChild","prototype","previousSibling","parent","firstChild","lastChild","newChild","push","toString","string","value","map","child","idx","join","split","line","Node","types","define","name","postProcess","methodName","substring","toUpperCase","postProcessGiven","options","node","level","src","exports","exportModule","module","exportedName","hasOwnProperty","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","nodes","lexer","toc","num","^","multilineCell","document","directiveValues","convert","ConverterClass","exportOptions","result","parse","parseDocument","createErrorReport","message","Error","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","fromLineNumber","appendNode","newNode","parseTitle","hasNext","element","parseElement","title","createTextNode","content","pushDummyTokenByType","header","parseHeader","preformatted","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableRow","tableSeparator","parseTable","parseParagraph","horizontalRule","createHorizontalRule","directive","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","createHeader","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","isDefinitionList","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","listElement","createListElement","match","exec","term","notBlankNextToken","pushToken","table","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","isHeader","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","text","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","directiveName","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","matched","createDirective","toLowerCase","directiveArguments","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","directiveRawValue","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","paragraph","createParagraph","noEmphasis","lineToken","createText","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","body","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","link","createLink","createBold","createItalic","createUnderline","createCode","createDashed","RegExp","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","$2","$1","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName","Converter","ConverterHTML","orgDocument","initialize","__proto__","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","computeToc","documentOptions","tocHTML","tocToHTML","tocToHTMLFunction","tocList","html","tocItem","sectionNumberText","headerNode","sectionNumber","inlineTag","class","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","inlineContainer","attributesNode","attributesText","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","checkboxAttributes","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","convertHTML","textNode","convertHeaderBlock","headerBlock","index","contents","blockContent","childNodes","childBlockContent","childBlocks","block","contentsText","replaceMap","&","<",">","\"","'","->","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","predicate","currentText","exportFromLineNumber","data-line-number","makeLink","url","decodeURIComponent","makeSubscript","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","innerText","auxAttributesText","htmlString","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","k","recordHeader","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","termText","tableCell","bold","italic","underline","code","dashed","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern"],"mappings":"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","file":"js/org.3189cf48ba9f17187bb9.js","sourcesContent":["/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n"],"sourceRoot":""}