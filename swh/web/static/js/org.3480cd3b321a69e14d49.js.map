{"version":3,"sources":["webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js","webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js"],"names":["PrototypeNode","type","children","this","i","len","length","appendChild","prototype","previousSibling","parent","newChild","lastChild","push","toString","string","value","map","child","idx","join","split","line","Node","types","define","name","postProcess","methodName","substring","toUpperCase","postProcessGiven","options","node","level","src","exports","exportModule","module","exportedName","hasOwnProperty","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","nodes","lexer","toc","num","multilineCell","key","document","directiveValues","convert","ConverterClass","exportOptions","result","parse","parseDocument","createErrorReport","message","Error","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","fromLineNumber","appendNode","newNode","parseTitle","hasNext","element","parseElement","title","createTextNode","content","pushDummyTokenByType","header","parseHeader","preformatted","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableRow","tableSeparator","parseTable","parseParagraph","horizontalRule","createHorizontalRule","directive","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","createHeader","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","isDefinitionList","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","listElement","createListElement","match","exec","term","notBlankNextToken","pushToken","table","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","isHeader","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","text","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","directiveName","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","matched","createDirective","toLowerCase","directiveArguments","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","directiveRawValue","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","paragraph","createParagraph","noEmphasis","lineToken","createText","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","body","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","link","createLink","createBold","createItalic","createUnderline","createCode","createDashed","RegExp","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","$2","$1","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName","Converter","ConverterHTML","orgDocument","initialize","__proto__","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","computeToc","documentOptions","tocHTML","tocToHTML","tocToHTMLFunction","tocList","html","tocItem","sectionNumberText","headerNode","sectionNumber","inlineTag","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","inlineContainer","attributesNode","attributesText","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","checkboxAttributes","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","convertHTML","textNode","convertHeaderBlock","headerBlock","index","contents","blockContent","childNodes","childBlockContent","childBlocks","block","contentsText","replaceMap","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","predicate","currentText","exportFromLineNumber","makeLink","url","decodeURIComponent","makeSubscript","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","innerText","auxAttributesText","htmlString","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","k","recordHeader","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","termText","tableCell","bold","italic","underline","code","dashed","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern"],"mappings":"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","file":"js/org.3480cd3b321a69e14d49.js","sourcesContent":["/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n"],"sourceRoot":""}