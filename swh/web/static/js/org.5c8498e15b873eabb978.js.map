{"version":3,"sources":["webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js","webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js","webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js"],"names":["exportModule","module","exportedName","hasOwnProperty","exports","__webpack_require__","Stream","Lexer","Node","Parser","this","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","options","parser","initStatus","parseNodes","nodes","prototype","lexer","toc","num","^","multilineCell","key","document","directiveValues","convert","ConverterClass","exportOptions","result","parse","parseDocument","createErrorReport","message","Error","getLineNumber","skipBlank","blankToken","peekNextToken","type","tokens","blank","getNextToken","setNodeOriginFromToken","node","token","fromLineNumber","appendNode","newNode","previousSibling","length","push","parseTitle","hasNext","element","parseElement","line","title","createTextNode","content","pushDummyTokenByType","header","parseHeader","preformatted","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableRow","tableSeparator","parseTable","parseParagraph","horizontalRule","createHorizontalRule","directive","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","createHeader","level","preformattedFirstToken","createPreformatted","textContents","indentation","appendChild","join","definitionPattern","list","rootToken","isDefinitionList","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","listElement","createListElement","match","exec","term","notBlankNextToken","pushToken","table","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","children","forEach","cell","isHeader","tableRowTokens","firstTableRowToken","shift","tableCellTexts","split","rowToken","cellText","cellIdx","tableCells","map","text","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","directiveName","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","matched","createDirective","toLowerCase","directiveArguments","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","directiveRawValue","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","paragraph","createParagraph","noEmphasis","lineToken","createText","value","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","body","post","matchBegin","beforeContent","substring","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","src","link","createLink","createBold","createItalic","createUnderline","createCode","createDashed","RegExp","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","define","name","syntax","toUpperCase","Token","tokenStack","tokenize","$2","$1","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName","i","Converter","ConverterHTML","orgDocument","initialize","__proto__","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","computeToc","documentOptions","tocHTML","tocToHTML","toString","tocToHTMLFunction","tocList","html","tocItem","sectionNumberText","headerNode","sectionNumber","inlineTag","class","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","parent","types","inlineContainer","attributesNode","attributesText","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","checkboxAttributes","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","convertHTML","textNode","convertHeaderBlock","headerBlock","index","contents","blockContent","childNodes","childBlockContent","childBlocks","block","idx","contentsText","replaceMap","&","<",">","\"","'","->","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","predicate","postProcess","currentText","exportFromLineNumber","data-line-number","makeLink","url","decodeURIComponent","makeSubscript","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","innerText","auxAttributesText","htmlString","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","k","recordHeader","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","termText","tableCell","bold","italic","underline","code","dashed","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern","r","__webpack_exports__","org__WEBPACK_IMPORTED_MODULE_1__","__WEBPACK_IMPORT_KEY__","d","PrototypeNode","len","firstChild","lastChild","newChild","string","child","methodName","postProcessGiven"],"mappings":"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","file":"js/org.5c8498e15b873eabb978.js","sourcesContent":["if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n"],"sourceRoot":""}