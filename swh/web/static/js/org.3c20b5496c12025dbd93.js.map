{"version":3,"sources":["webpack://swh.org/./node_modules/org/lib/org/converter/html.js","webpack://swh.org/./node_modules/org/lib/org/converter/converter.js","webpack://swh.org/./swh/web/assets/src/utils/org.js","webpack://swh.org/./node_modules/org/lib/org/node.js","webpack://swh.org/./node_modules/org/lib/org.js","webpack://swh.org/./node_modules/org/lib/org/parser.js","webpack://swh.org/./node_modules/org/lib/org/stream.js","webpack://swh.org/./node_modules/org/lib/org/lexer.js"],"names":["Converter","__webpack_require__","Node","ConverterHTML","orgDocument","exportOptions","this","initialize","result","convert","prototype","__proto__","title","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","nodes","toc","computeToc","documentOptions","tocHTML","tocToHTML","toString","tocToHTMLFunction","tocList","html","i","length","tocItem","sectionNumberText","headerNode","sectionNumber","num","inlineTag","class","header","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","node","parent","type","types","inlineContainer","attributesNode","previousSibling","attributesText","directive","directiveName","directiveRawValue","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","substring","level","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","term","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","exec","RegExp","$2","checkboxAttributes","$1","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","src","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","directiveArguments","convertHTML","children","map","textNode","value","join","convertHeaderBlock","headerBlock","index","contents","push","blockContent","childNodes","childBlockContent","childBlocks","block","idx","contentsText","replaceMap","&","<",">","\"","'","->","text","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","matched","Error","predicate","postProcess","currentText","exportFromLineNumber","fromLineNumber","data-line-number","makeLink","url","decodeURIComponent","makeSubscript","match","body","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","hasOwnProperty","attributeValue","name","innerText","auxAttributesText","htmlString","exports","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","options","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","createHeader","k","recordHeader","preformatted","createText","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","listElement","isDefinitionList","termText","paragraph","table","tableRow","tableCell","isHeader","horizontalRule","bold","italic","underline","code","dashed","link","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern","r","__webpack_exports__","org__WEBPACK_IMPORTED_MODULE_1__","__WEBPACK_IMPORT_KEY__","key","d","PrototypeNode","len","appendChild","firstChild","lastChild","newChild","string","child","split","line","define","methodName","toUpperCase","postProcessGiven","exportModule","module","exportedName","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","lexer","^","multilineCell","document","directiveValues","ConverterClass","parse","parseDocument","createErrorReport","message","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","appendNode","newNode","parseTitle","hasNext","element","parseElement","createTextNode","content","pushDummyTokenByType","parseHeader","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableSeparator","parseTable","parseParagraph","createHorizontalRule","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","createListElement","notBlankNextToken","pushToken","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","createDirective","toLowerCase","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","createParagraph","noEmphasis","lineToken","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","createLink","createBold","createItalic","createUnderline","createCode","createDashed","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName"],"mappings":"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","file":"js/org.3c20b5496c12025dbd93.js","sourcesContent":["var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n","function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n"],"sourceRoot":""}