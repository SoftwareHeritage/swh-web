{"version":3,"sources":["webpack://swh.[name]/./node_modules/org/lib/org/node.js","webpack://swh.[name]/./node_modules/org/lib/org.js","webpack://swh.[name]/./node_modules/org/lib/org/parser.js","webpack://swh.[name]/./node_modules/org/lib/org/stream.js","webpack://swh.[name]/./node_modules/org/lib/org/lexer.js","webpack://swh.[name]/./node_modules/org/lib/org/converter/html.js","webpack://swh.[name]/./node_modules/org/lib/org/converter/converter.js","webpack://swh.[name]/./swh/web/assets/src/utils/org.js"],"names":["PrototypeNode","type","children","this","i","len","length","appendChild","prototype","previousSibling","parent","firstChild","lastChild","newChild","push","toString","string","value","map","child","idx","join","split","line","Node","types","define","name","postProcess","methodName","substring","toUpperCase","postProcessGiven","options","node","level","src","exports","exportModule","module","exportedName","hasOwnProperty","__webpack_require__","Stream","Lexer","Parser","inlineParser","InlineParser","preEmphasis","postEmphasis","borderForbidden","bodyRegexp","markers","emphasisPattern","buildEmphasisPattern","linkPattern","parseStream","stream","parser","initStatus","parseNodes","nodes","lexer","toc","num","^","multilineCell","key","document","directiveValues","convert","ConverterClass","exportOptions","result","parse","parseDocument","createErrorReport","message","Error","getLineNumber","skipBlank","blankToken","peekNextToken","tokens","blank","getNextToken","setNodeOriginFromToken","token","fromLineNumber","appendNode","newNode","parseTitle","hasNext","element","parseElement","title","createTextNode","content","pushDummyTokenByType","header","parseHeader","preformatted","parsePreformatted","orderedListElement","unorderedListElement","parseList","parseText","tableRow","tableSeparator","parseTable","parseParagraph","horizontalRule","createHorizontalRule","directive","parseDirective","comment","parseElementBesidesDirectiveEnd","parseElementBesidesDirectiveEndBody","originalParseElement","endDirective","headerToken","createHeader","preformattedFirstToken","createPreformatted","textContents","indentation","definitionPattern","list","rootToken","isDefinitionList","test","createDefinitionList","createUnorderedList","createOrderedList","nextToken","isListElement","parseListElement","unknownDefinitionTerm","rootIndentation","listElementToken","listElement","createListElement","match","exec","term","notBlankNextToken","pushToken","table","createTable","sawSeparator","allowMultilineCell","isTableElement","parseTableRow","forEach","cell","isHeader","tableRowTokens","firstTableRowToken","shift","tableCellTexts","rowToken","cellText","cellIdx","tableCells","text","createTableCell","createTableRow","directiveToken","directiveNode","createDirectiveNodeFromToken","directiveName","oneshotDirective","interpretDirective","beginDirective","isVerbatimDirective","parseDirectiveBlockVerbatim","parseDirectiveBlock","matched","createDirective","toLowerCase","directiveArguments","parseDirectiveArguments","directiveOptions","parseDirectiveOptions","directiveRawValue","verbatim","textContent","getNextLine","parameters","filter","param","interpretOptionDirective","author","email","optionDirectiveNode","pairString","pair","convertLispyValue","lispyValue","parseInt","paragraphFisrtToken","paragraph","createParagraph","noEmphasis","lineToken","createText","parseEmphasis","lastIndex","savedLastIndex","previousLast","whole","pre","marker","body","post","matchBegin","beforeContent","parseLink","bodyNode","bodyContainer","emphasizeElementByMarker","createInlineContainer","depth","link","createLink","createBold","createItalic","createUnderline","createCode","createDashed","RegExp","sequence","sequences","totalLines","lineNumber","peekNextLine","Syntax","rules","syntax","Token","tokenStack","tokenize","$2","$1","isPreformatted","isUnorderedListElement","isOrderedListElement","$3","number","isTableSeparator","isTableRow","isBlank","isHorizontalRule","isDirective","directiveTypeString","isComment","isLine","peekStackedToken","getStackedToken","pop","tokenName","Converter","ConverterHTML","orgDocument","initialize","__proto__","convertNode","untitled","titleHTML","tag","Math","max","Number","headerOffset","contentHTML","convertNodes","computeToc","documentOptions","tocHTML","tocToHTML","tocToHTMLFunction","tocList","html","tocItem","sectionNumberText","headerNode","sectionNumber","inlineTag","class","getNodeTextContent","headerLink","href","replace","subList","childTocs","call","computeAuxDataForNode","inlineContainer","attributesNode","attributesText","orgClassName","className","htmlClassPrefix","orgId","id","htmlIdPrefix","convertHeader","childText","auxData","taskStatus","headerAttributes","convertOrderedList","convertUnorderedList","convertDefinitionList","convertDefinitionItem","definition","convertListItem","suppressCheckboxHandling","listItemAttributes","listItemText","checkboxAttributes","convertParagraph","convertPreformatted","convertTable","convertTableRow","convertTableHeader","convertTableCell","convertHorizontalRule","convertInlineContainer","convertBold","convertItalic","convertUnderline","style","convertCode","convertDashed","convertLink","srcParameterStripped","stripParametersFromURL","imageExtensionPattern","imgText","alt","convertQuote","convertExample","convertSrc","codeLanguage","convertHTML","textNode","convertHeaderBlock","headerBlock","index","contents","blockContent","childNodes","childBlockContent","childBlocks","block","contentsText","replaceMap","&","<",">","\"","'","->","insideCodeElement","translateSymbolArrow","replaceRegexp","escapeSpecialChars","Object","keys","self","predicate","currentText","exportFromLineNumber","data-line-number","makeLink","url","decodeURIComponent","makeSubscript","subscript","attributesObjectToString","attributesObject","attributesString","attributeName","attributeValue","innerText","auxAttributesText","htmlString","suppressSubScriptHandling","suppressAutoLink","customDirectiveHandler","headers","sectionNumbers","createTocItem","parentTocs","exportTocLevel","Infinity","previousLevel","currentTocs","levelDiff","j","dummyHeader","k","recordHeader","convertNodesInternal","indexOf","thisHeaderLevel","previousHeaderLevel","orderedList","unorderedList","definitionList","termText","tableCell","bold","italic","underline","code","dashed","convertText","escapedText","makeSubscripts","linkURL","nodesTexts","nodeText","combineNodesTexts","convertHeaderTree","headerTree","convertNodesToHeaderTree","nextBlockBegin","blockHeader","childBlock","nextIndex","urlPattern","r","__webpack_exports__","org__WEBPACK_IMPORTED_MODULE_1__","__WEBPACK_IMPORT_KEY__","d"],"mappings":"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","file":"js/org.51bbad36f29d2d96eb01.js","sourcesContent":["function PrototypeNode(type, children) {\n  this.type = type;\n  this.children = [];\n\n  if (children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n      this.appendChild(children[i]);\n    }\n  }\n}\nPrototypeNode.prototype = {\n  previousSibling: null,\n  parent: null,\n  get firstChild() {\n    return this.children.length < 1 ?\n      null : this.children[0];\n  },\n  get lastChild() {\n    return this.children.length < 1 ?\n      null : this.children[this.children.length - 1];\n  },\n  appendChild: function (newChild) {\n    var previousSibling = this.children.length < 1 ?\n          null : this.lastChild;\n    this.children.push(newChild);\n    newChild.previousSibling = previousSibling;\n    newChild.parent = this;\n  },\n  toString: function () {\n    var string = \"<\" + this.type + \">\";\n\n    if (typeof this.value !== \"undefined\") {\n      string += \" \" + this.value;\n    } else if (this.children) {\n      string += \"\\n\" + this.children.map(function (child, idx) {\n        return \"#\" + idx + \" \" + child.toString();\n      }).join(\"\\n\").split(\"\\n\").map(function (line) {\n        return \"  \" + line;\n      }).join(\"\\n\");\n    }\n\n    return string;\n  }\n};\n\nvar Node = {\n  types: {},\n\n  define: function (name, postProcess) {\n    this.types[name] = name;\n\n    var methodName = \"create\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    var postProcessGiven = typeof postProcess === \"function\";\n\n    this[methodName] = function (children, options) {\n      var node = new PrototypeNode(name, children);\n\n      if (postProcessGiven)\n        postProcess(node, options || {});\n\n      return node;\n    };\n  }\n};\n\nNode.define(\"text\", function (node, options) {\n  node.value = options.value;\n});\nNode.define(\"header\", function (node, options) {\n  node.level = options.level;\n});\nNode.define(\"orderedList\");\nNode.define(\"unorderedList\");\nNode.define(\"definitionList\");\nNode.define(\"listElement\");\nNode.define(\"paragraph\");\nNode.define(\"preformatted\");\nNode.define(\"table\");\nNode.define(\"tableRow\");\nNode.define(\"tableCell\");\nNode.define(\"horizontalRule\");\nNode.define(\"directive\");\n\n// Inline\nNode.define(\"inlineContainer\");\n\nNode.define(\"bold\");\nNode.define(\"italic\");\nNode.define(\"underline\");\nNode.define(\"code\");\nNode.define(\"verbatim\");\nNode.define(\"dashed\");\nNode.define(\"link\", function (node, options) {\n  node.src = options.src;\n});\n\nif (typeof exports !== \"undefined\")\n  exports.Node = Node;\n","if (typeof exports !== \"undefined\") {\n  function exportModule(module) {\n    for (var exportedName in module) {\n      if (module.hasOwnProperty(exportedName)) {\n        exports[exportedName] = module[exportedName];\n      }\n    }\n  }\n\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/lexer.js\"));\n  exportModule(require(\"./org/node.js\"));\n  exportModule(require(\"./org/parser.js\"));\n  exportModule(require(\"./org/stream.js\"));\n  exportModule(require(\"./org/converter/html.js\"));\n}\n","var Stream = require(\"./stream.js\").Stream;\nvar Lexer  = require(\"./lexer.js\").Lexer;\nvar Node   = require(\"./node.js\").Node;\n\nfunction Parser() {\n  this.inlineParser = new InlineParser();\n}\n\nParser.parseStream = function (stream, options) {\n  var parser = new Parser();\n  parser.initStatus(stream, options);\n  parser.parseNodes();\n  return parser.nodes;\n};\n\nParser.prototype = {\n  initStatus: function (stream, options) {\n    if (typeof stream === \"string\")\n      stream = new Stream(stream);\n    this.lexer = new Lexer(stream);\n    this.nodes = [];\n    this.options = {\n      toc: true,\n      num: true,\n      \"^\": \"{}\",\n      multilineCell: false\n    };\n    // Override option values\n    if (options && typeof options === \"object\") {\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n    }\n    this.document = {\n      options: this.options,\n      directiveValues: {},\n      convert: function (ConverterClass, exportOptions) {\n        var converter = new ConverterClass(this, exportOptions);\n        return converter.result;\n      }\n    };\n  },\n\n  parse: function (stream, options) {\n    this.initStatus(stream, options);\n    this.parseDocument();\n    this.document.nodes = this.nodes;\n    return this.document;\n  },\n\n  createErrorReport: function (message) {\n    return new Error(message + \" at line \" + this.lexer.getLineNumber());\n  },\n\n  skipBlank: function () {\n    var blankToken = null;\n    while (this.lexer.peekNextToken().type === Lexer.tokens.blank)\n      blankToken = this.lexer.getNextToken();\n    return blankToken;\n  },\n\n  setNodeOriginFromToken: function (node, token) {\n    node.fromLineNumber = token.fromLineNumber;\n    return node;\n  },\n\n  appendNode: function (newNode) {\n    var previousSibling = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1] : null;\n    this.nodes.push(newNode);\n    newNode.previousSibling = previousSibling;\n  },\n\n  // ------------------------------------------------------------\n  // <Document> ::= <Element>*\n  // ------------------------------------------------------------\n\n  parseDocument: function () {\n    this.parseTitle();\n    this.parseNodes();\n  },\n\n  parseNodes: function () {\n    while (this.lexer.hasNext()) {\n      var element = this.parseElement();\n      if (element) this.appendNode(element);\n    }\n  },\n\n  parseTitle: function () {\n    this.skipBlank();\n\n    if (this.lexer.hasNext() &&\n        this.lexer.peekNextToken().type === Lexer.tokens.line)\n      this.document.title = this.createTextNode(this.lexer.getNextToken().content);\n    else\n      this.document.title = null;\n\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n  },\n\n  // ------------------------------------------------------------\n  // <Element> ::= (<Header> | <List>\n  //              | <Preformatted> | <Paragraph>\n  //              | <Table>)*\n  // ------------------------------------------------------------\n\n  parseElement: function () {\n    var element = null;\n\n    switch (this.lexer.peekNextToken().type) {\n    case Lexer.tokens.header:\n      element = this.parseHeader();\n      break;\n    case Lexer.tokens.preformatted:\n      element = this.parsePreformatted();\n      break;\n    case Lexer.tokens.orderedListElement:\n    case Lexer.tokens.unorderedListElement:\n      element = this.parseList();\n      break;\n    case Lexer.tokens.line:\n      element = this.parseText();\n      break;\n    case Lexer.tokens.tableRow:\n    case Lexer.tokens.tableSeparator:\n      element = this.parseTable();\n      break;\n    case Lexer.tokens.blank:\n      this.skipBlank();\n      if (this.lexer.hasNext()) {\n        if (this.lexer.peekNextToken().type === Lexer.tokens.line)\n          element = this.parseParagraph();\n        else\n          element = this.parseElement();\n      }\n      break;\n    case Lexer.tokens.horizontalRule:\n      this.lexer.getNextToken();\n      element = Node.createHorizontalRule();\n      break;\n    case Lexer.tokens.directive:\n      element = this.parseDirective();\n      break;\n    case Lexer.tokens.comment:\n      // Skip\n      this.lexer.getNextToken();\n      break;\n    default:\n      throw this.createErrorReport(\"Unhandled token: \" + this.lexer.peekNextToken().type);\n    }\n\n    return element;\n  },\n\n  parseElementBesidesDirectiveEnd: function () {\n    try {\n      // Temporary, override the definition of `parseElement`\n      this.parseElement = this.parseElementBesidesDirectiveEndBody;\n      return this.parseElement();\n    } finally {\n      this.parseElement = this.originalParseElement;\n    }\n  },\n\n  parseElementBesidesDirectiveEndBody: function () {\n    if (this.lexer.peekNextToken().type === Lexer.tokens.directive &&\n        this.lexer.peekNextToken().endDirective) {\n      return null;\n    }\n\n    return this.originalParseElement();\n  },\n\n  // ------------------------------------------------------------\n  // <Header>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parseHeader: function () {\n    var headerToken = this.lexer.getNextToken();\n    var header = Node.createHeader([\n      this.createTextNode(headerToken.content) // TODO: Parse inline markups\n    ], { level: headerToken.level });\n    this.setNodeOriginFromToken(header, headerToken);\n\n    return header;\n  },\n\n  // ------------------------------------------------------------\n  // <Preformatted>\n  //\n  // : preformatted\n  // : block\n  // ------------------------------------------------------------\n\n  parsePreformatted: function () {\n    var preformattedFirstToken = this.lexer.peekNextToken();\n    var preformatted = Node.createPreformatted([]);\n    this.setNodeOriginFromToken(preformatted, preformattedFirstToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var token = this.lexer.peekNextToken();\n      if (token.type !== Lexer.tokens.preformatted ||\n          token.indentation < preformattedFirstToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(token.content);\n    }\n\n    preformatted.appendChild(this.createTextNode(textContents.join(\"\\n\"), true /* no emphasis */));\n\n    return preformatted;\n  },\n\n  // ------------------------------------------------------------\n  // <List>\n  //\n  //  - foo\n  //    1. bar\n  //    2. baz\n  // ------------------------------------------------------------\n\n  // XXX: not consider codes (e.g., =Foo::Bar=)\n  definitionPattern: /^(.*?) :: *(.*)$/,\n\n  parseList: function () {\n    var rootToken = this.lexer.peekNextToken();\n    var list;\n    var isDefinitionList = false;\n\n    if (this.definitionPattern.test(rootToken.content)) {\n      list = Node.createDefinitionList([]);\n      isDefinitionList = true;\n    } else {\n      list = rootToken.type === Lexer.tokens.unorderedListElement ?\n        Node.createUnorderedList([]) : Node.createOrderedList([]);\n    }\n    this.setNodeOriginFromToken(list, rootToken);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (!nextToken.isListElement() || nextToken.indentation !== rootToken.indentation)\n        break;\n      list.appendChild(this.parseListElement(rootToken.indentation, isDefinitionList));\n    }\n\n    return list;\n  },\n\n  unknownDefinitionTerm: \"???\",\n\n  parseListElement: function (rootIndentation, isDefinitionList) {\n    var listElementToken = this.lexer.getNextToken();\n    var listElement = Node.createListElement([]);\n    this.setNodeOriginFromToken(listElement, listElementToken);\n\n    listElement.isDefinitionList = isDefinitionList;\n\n    if (isDefinitionList) {\n      var match = this.definitionPattern.exec(listElementToken.content);\n      listElement.term = [\n        this.createTextNode(match && match[1] ? match[1] : this.unknownDefinitionTerm)\n      ];\n      listElement.appendChild(this.createTextNode(match ? match[2] : listElementToken.content));\n    } else {\n      listElement.appendChild(this.createTextNode(listElementToken.content));\n    }\n\n    while (this.lexer.hasNext()) {\n      var blankToken = this.skipBlank();\n      if (!this.lexer.hasNext())\n        break;\n\n      var notBlankNextToken = this.lexer.peekNextToken();\n      if (blankToken && !notBlankNextToken.isListElement())\n        this.lexer.pushToken(blankToken); // Recover blank token only when next line is not listElement.\n      if (notBlankNextToken.indentation <= rootIndentation)\n        break;                  // end of the list\n\n      var element = this.parseElement(); // recursive\n      if (element)\n        listElement.appendChild(element);\n    }\n\n    return listElement;\n  },\n\n  // ------------------------------------------------------------\n  // <Table> ::= <TableRow>+\n  // ------------------------------------------------------------\n\n  parseTable: function () {\n    var nextToken = this.lexer.peekNextToken();\n    var table = Node.createTable([]);\n    this.setNodeOriginFromToken(table, nextToken);\n    var sawSeparator = false;\n\n    var allowMultilineCell = nextToken.type === Lexer.tokens.tableSeparator && this.options.multilineCell;\n\n    while (this.lexer.hasNext() &&\n           (nextToken = this.lexer.peekNextToken()).isTableElement()) {\n      if (nextToken.type === Lexer.tokens.tableRow) {\n        var tableRow = this.parseTableRow(allowMultilineCell);\n        table.appendChild(tableRow);\n      } else {\n        // Lexer.tokens.tableSeparator\n        sawSeparator = true;\n        this.lexer.getNextToken();\n      }\n    }\n\n    if (sawSeparator && table.children.length) {\n      table.children[0].children.forEach(function (cell) {\n        cell.isHeader = true;\n      });\n    }\n\n    return table;\n  },\n\n  // ------------------------------------------------------------\n  // <TableRow> ::= <TableCell>+\n  // ------------------------------------------------------------\n\n  parseTableRow: function (allowMultilineCell) {\n    var tableRowTokens = [];\n\n    while (this.lexer.peekNextToken().type === Lexer.tokens.tableRow) {\n      tableRowTokens.push(this.lexer.getNextToken());\n      if (!allowMultilineCell) {\n        break;\n      }\n    }\n\n    if (!tableRowTokens.length) {\n      throw this.createErrorReport(\"Expected table row\");\n    }\n\n    var firstTableRowToken = tableRowTokens.shift();\n    var tableCellTexts = firstTableRowToken.content.split(\"|\");\n\n    tableRowTokens.forEach(function (rowToken) {\n      rowToken.content.split(\"|\").forEach(function (cellText, cellIdx) {\n        tableCellTexts[cellIdx] = (tableCellTexts[cellIdx] || \"\") + \"\\n\" + cellText;\n      });\n    });\n\n    // TODO: Prepare two pathes: (1)\n    var tableCells = tableCellTexts.map(\n      // TODO: consider '|' escape?\n      function (text) {\n        return Node.createTableCell(Parser.parseStream(text));\n      }, this);\n\n    return this.setNodeOriginFromToken(Node.createTableRow(tableCells), firstTableRowToken);\n  },\n\n  // ------------------------------------------------------------\n  // <Directive> ::= \"#+.*\"\n  // ------------------------------------------------------------\n\n  parseDirective: function () {\n    var directiveToken = this.lexer.getNextToken();\n    var directiveNode = this.createDirectiveNodeFromToken(directiveToken);\n\n    if (directiveToken.endDirective)\n      throw this.createErrorReport(\"Unmatched 'end' directive for \" + directiveNode.directiveName);\n\n    if (directiveToken.oneshotDirective) {\n      this.interpretDirective(directiveNode);\n      return directiveNode;\n    }\n\n    if (!directiveToken.beginDirective)\n      throw this.createErrorReport(\"Invalid directive \" + directiveNode.directiveName);\n\n    // Parse begin ~ end\n    directiveNode.children = [];\n    if (this.isVerbatimDirective(directiveNode))\n      return this.parseDirectiveBlockVerbatim(directiveNode);\n    else\n      return this.parseDirectiveBlock(directiveNode);\n  },\n\n  createDirectiveNodeFromToken: function (directiveToken) {\n    var matched = /^[ ]*([^ ]*)[ ]*(.*)[ ]*$/.exec(directiveToken.content);\n\n    var directiveNode = Node.createDirective(null);\n    this.setNodeOriginFromToken(directiveNode, directiveToken);\n    directiveNode.directiveName = matched[1].toLowerCase();\n    directiveNode.directiveArguments = this.parseDirectiveArguments(matched[2]);\n    directiveNode.directiveOptions = this.parseDirectiveOptions(matched[2]);\n    directiveNode.directiveRawValue = matched[2];\n\n    return directiveNode;\n  },\n\n  isVerbatimDirective: function (directiveNode) {\n    var directiveName = directiveNode.directiveName;\n    return directiveName === \"src\" || directiveName === \"example\" || directiveName === \"html\";\n  },\n\n  parseDirectiveBlock: function (directiveNode, verbatim) {\n    this.lexer.pushDummyTokenByType(Lexer.tokens.blank);\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        // Close directive\n        this.lexer.getNextToken();\n        return directiveNode;\n      }\n      var element = this.parseElementBesidesDirectiveEnd();\n      if (element)\n        directiveNode.appendChild(element);\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveBlockVerbatim: function (directiveNode) {\n    var textContent = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type === Lexer.tokens.directive &&\n          nextToken.endDirective &&\n          this.createDirectiveNodeFromToken(nextToken).directiveName === directiveNode.directiveName) {\n        this.lexer.getNextToken();\n        directiveNode.appendChild(this.createTextNode(textContent.join(\"\\n\"), true));\n        return directiveNode;\n      }\n      textContent.push(this.lexer.stream.getNextLine());\n    }\n\n    throw this.createErrorReport(\"Unclosed directive \" + directiveNode.directiveName);\n  },\n\n  parseDirectiveArguments: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] !== \"-\";\n    });\n  },\n\n  parseDirectiveOptions: function (parameters) {\n    return parameters.split(/[ ]+/).filter(function (param) {\n      return param.length && param[0] === \"-\";\n    });\n  },\n\n  interpretDirective: function (directiveNode) {\n    // http://orgmode.org/manual/Export-options.html\n    switch (directiveNode.directiveName) {\n    case \"options:\":\n      this.interpretOptionDirective(directiveNode);\n      break;\n    case \"title:\":\n      this.document.title = directiveNode.directiveRawValue;\n      break;\n    case \"author:\":\n      this.document.author = directiveNode.directiveRawValue;\n      break;\n    case \"email:\":\n      this.document.email = directiveNode.directiveRawValue;\n      break;\n    default:\n      this.document.directiveValues[directiveNode.directiveName] = directiveNode.directiveRawValue;\n      break;\n    }\n  },\n\n  interpretOptionDirective: function (optionDirectiveNode) {\n    optionDirectiveNode.directiveArguments.forEach(function (pairString) {\n      var pair = pairString.split(\":\");\n      this.options[pair[0]] = this.convertLispyValue(pair[1]);\n    }, this);\n  },\n\n  convertLispyValue: function (lispyValue) {\n    switch (lispyValue) {\n    case \"t\":\n      return true;\n    case \"nil\":\n      return false;\n    default:\n      if (/^[0-9]+$/.test(lispyValue))\n        return parseInt(lispyValue);\n      return lispyValue;\n    }\n  },\n\n  // ------------------------------------------------------------\n  // <Paragraph> ::= <Blank> <Line>*\n  // ------------------------------------------------------------\n\n  parseParagraph: function () {\n    var paragraphFisrtToken = this.lexer.peekNextToken();\n    var paragraph = Node.createParagraph([]);\n    this.setNodeOriginFromToken(paragraph, paragraphFisrtToken);\n\n    var textContents = [];\n\n    while (this.lexer.hasNext()) {\n      var nextToken = this.lexer.peekNextToken();\n      if (nextToken.type !== Lexer.tokens.line\n          || nextToken.indentation < paragraphFisrtToken.indentation)\n        break;\n      this.lexer.getNextToken();\n      textContents.push(nextToken.content);\n    }\n\n    paragraph.appendChild(this.createTextNode(textContents.join(\"\\n\")));\n\n    return paragraph;\n  },\n\n  parseText: function (noEmphasis) {\n    var lineToken = this.lexer.getNextToken();\n    return this.createTextNode(lineToken.content, noEmphasis);\n  },\n\n  // ------------------------------------------------------------\n  // <Text> (DOM Like)\n  // ------------------------------------------------------------\n\n  createTextNode: function (text, noEmphasis) {\n    return noEmphasis ? Node.createText(null, { value: text })\n      : this.inlineParser.parseEmphasis(text);\n  }\n};\nParser.prototype.originalParseElement = Parser.prototype.parseElement;\n\n// ------------------------------------------------------------\n// Parser for Inline Elements\n//\n// @refs org-emphasis-regexp-components\n// ------------------------------------------------------------\n\nfunction InlineParser() {\n  this.preEmphasis     = \" \\t\\\\('\\\"\";\n  this.postEmphasis    = \"- \\t.,:!?;'\\\"\\\\)\";\n  this.borderForbidden = \" \\t\\r\\n,\\\"'\";\n  this.bodyRegexp      = \"[\\\\s\\\\S]*?\";\n  this.markers         = \"*/_=~+\";\n\n  this.emphasisPattern = this.buildEmphasisPattern();\n  this.linkPattern = /\\[\\[([^\\]]*)\\](?:\\[([^\\]]*)\\])?\\]/g; // \\1 => link, \\2 => text\n}\n\nInlineParser.prototype = {\n  parseEmphasis: function (text) {\n    var emphasisPattern = this.emphasisPattern;\n    emphasisPattern.lastIndex = 0;\n\n    var result = [],\n        match,\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = emphasisPattern.exec(text))) {\n      var whole  = match[0];\n      var pre    = match[1];\n      var marker = match[2];\n      var body   = match[3];\n      var post   = match[4];\n\n      {\n        // parse links\n        var matchBegin = emphasisPattern.lastIndex - whole.length;\n        var beforeContent = text.substring(previousLast, matchBegin + pre.length);\n        savedLastIndex = emphasisPattern.lastIndex;\n        result.push(this.parseLink(beforeContent));\n        emphasisPattern.lastIndex = savedLastIndex;\n      }\n\n      var bodyNode = [Node.createText(null, { value: body })];\n      var bodyContainer = this.emphasizeElementByMarker(bodyNode, marker);\n      result.push(bodyContainer);\n\n      previousLast = emphasisPattern.lastIndex - post.length;\n    }\n\n    if (emphasisPattern.lastIndex === 0 ||\n        emphasisPattern.lastIndex !== text.length - 1)\n      result.push(this.parseLink(text.substring(previousLast)));\n\n    if (result.length === 1) {\n      // Avoid duplicated inline container wrapping\n      return result[0];\n    } else {\n      return Node.createInlineContainer(result);\n    }\n  },\n\n  depth: 0,\n  parseLink: function (text) {\n    var linkPattern = this.linkPattern;\n    linkPattern.lastIndex = 0;\n\n    var match,\n        result = [],\n        previousLast = 0,\n        savedLastIndex;\n\n    while ((match = linkPattern.exec(text))) {\n      var whole = match[0];\n      var src   = match[1];\n      var title = match[2];\n\n      // parse before content\n      var matchBegin = linkPattern.lastIndex - whole.length;\n      var beforeContent = text.substring(previousLast, matchBegin);\n      result.push(Node.createText(null, { value: beforeContent }));\n\n      // parse link\n      var link = Node.createLink([]);\n      link.src = src;\n      if (title) {\n        savedLastIndex = linkPattern.lastIndex;\n        link.appendChild(this.parseEmphasis(title));\n        linkPattern.lastIndex = savedLastIndex;\n      } else {\n        link.appendChild(Node.createText(null, { value: src }));\n      }\n      result.push(link);\n\n      previousLast = linkPattern.lastIndex;\n    }\n\n    if (linkPattern.lastIndex === 0 ||\n        linkPattern.lastIndex !== text.length - 1)\n      result.push(Node.createText(null, { value: text.substring(previousLast) }));\n\n    return Node.createInlineContainer(result);\n  },\n\n  emphasizeElementByMarker: function (element, marker) {\n    switch (marker) {\n    case \"*\":\n      return Node.createBold(element);\n    case \"/\":\n      return Node.createItalic(element);\n    case \"_\":\n      return Node.createUnderline(element);\n    case \"=\":\n    case \"~\":\n      return Node.createCode(element);\n    case \"+\":\n      return Node.createDashed(element);\n    }\n  },\n\n  buildEmphasisPattern: function () {\n    return new RegExp(\n      \"([\" + this.preEmphasis + \"]|^|\\r?\\n)\" +               // \\1 => pre\n        \"([\" + this.markers + \"])\" +                         // \\2 => marker\n        \"([^\" + this.borderForbidden + \"]|\" +                // \\3 => body\n        \"[^\" + this.borderForbidden + \"]\" +\n        this.bodyRegexp +\n        \"[^\" + this.borderForbidden + \"])\" +\n        \"\\\\2\" +\n        \"([\" + this.postEmphasis +\"]|$|\\r?\\n)\",              // \\4 => post\n        // flags\n        \"g\"\n    );\n  }\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Parser = Parser;\n  exports.InlineParser = InlineParser;\n}\n","function Stream(sequence) {\n  this.sequences = sequence.split(/\\r?\\n/);\n  this.totalLines = this.sequences.length;\n  this.lineNumber = 0;\n}\n\nStream.prototype.peekNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber] : null;\n};\n\nStream.prototype.getNextLine = function () {\n  return this.hasNext() ? this.sequences[this.lineNumber++] : null;\n};\n\nStream.prototype.hasNext = function () {\n  return this.lineNumber < this.totalLines;\n};\n\nif (typeof exports !== \"undefined\") {\n  exports.Stream = Stream;\n}\n","// ------------------------------------------------------------\n// Syntax\n// ------------------------------------------------------------\n\nvar Syntax = {\n  rules: {},\n\n  define: function (name, syntax) {\n    this.rules[name] = syntax;\n    var methodName = \"is\" + name.substring(0, 1).toUpperCase() + name.substring(1);\n    this[methodName] = function (line) {\n      return this.rules[name].exec(line);\n    };\n  }\n};\n\nSyntax.define(\"header\", /^(\\*+)\\s+(.*)$/); // m[1] => level, m[2] => content\nSyntax.define(\"preformatted\", /^(\\s*):(?: (.*)$|$)/); // m[1] => indentation, m[2] => content\nSyntax.define(\"unorderedListElement\", /^(\\s*)(?:-|\\+|\\s+\\*)\\s+(.*)$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"orderedListElement\", /^(\\s*)(\\d+)(?:\\.|\\))\\s+(.*)$/); // m[1] => indentation, m[2] => number, m[3] => content\nSyntax.define(\"tableSeparator\", /^(\\s*)\\|((?:\\+|-)*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"tableRow\", /^(\\s*)\\|(.*?)\\|?$/); // m[1] => indentation, m[2] => content\nSyntax.define(\"blank\", /^$/);\nSyntax.define(\"horizontalRule\", /^(\\s*)-{5,}$/); //\nSyntax.define(\"directive\", /^(\\s*)#\\+(?:(begin|end)_)?(.*)$/i); // m[1] => indentation, m[2] => type, m[3] => content\nSyntax.define(\"comment\", /^(\\s*)#(.*)$/);\nSyntax.define(\"line\", /^(\\s*)(.*)$/);\n\n// ------------------------------------------------------------\n// Token\n// ------------------------------------------------------------\n\nfunction Token() {\n}\n\nToken.prototype = {\n  isListElement: function () {\n    return this.type === Lexer.tokens.orderedListElement ||\n      this.type === Lexer.tokens.unorderedListElement;\n  },\n\n  isTableElement: function () {\n    return this.type === Lexer.tokens.tableSeparator ||\n      this.type === Lexer.tokens.tableRow;\n  }\n};\n\n// ------------------------------------------------------------\n// Lexer\n// ------------------------------------------------------------\n\nfunction Lexer(stream) {\n  this.stream = stream;\n  this.tokenStack = [];\n}\n\nLexer.prototype = {\n  tokenize: function (line) {\n    var token = new Token();\n    token.fromLineNumber = this.stream.lineNumber;\n\n    if (Syntax.isHeader(line)) {\n      token.type        = Lexer.tokens.header;\n      token.indentation = 0;\n      token.content     = RegExp.$2;\n      // specific\n      token.level       = RegExp.$1.length;\n    } else if (Syntax.isPreformatted(line)) {\n      token.type        = Lexer.tokens.preformatted;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isUnorderedListElement(line)) {\n      token.type        = Lexer.tokens.unorderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isOrderedListElement(line)) {\n      token.type        = Lexer.tokens.orderedListElement;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // specific\n      token.number      = RegExp.$2;\n    } else if (Syntax.isTableSeparator(line)) {\n      token.type        = Lexer.tokens.tableSeparator;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isTableRow(line)) {\n      token.type        = Lexer.tokens.tableRow;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isBlank(line)) {\n      token.type        = Lexer.tokens.blank;\n      token.indentation = 0;\n      token.content     = null;\n    } else if (Syntax.isHorizontalRule(line)) {\n      token.type        = Lexer.tokens.horizontalRule;\n      token.indentation = RegExp.$1.length;\n      token.content     = null;\n    } else if (Syntax.isDirective(line)) {\n      token.type        = Lexer.tokens.directive;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$3;\n      // decide directive type (begin, end or oneshot)\n      var directiveTypeString = RegExp.$2;\n      if (/^begin/i.test(directiveTypeString))\n        token.beginDirective = true;\n      else if (/^end/i.test(directiveTypeString))\n        token.endDirective = true;\n      else\n        token.oneshotDirective = true;\n    } else if (Syntax.isComment(line)) {\n      token.type        = Lexer.tokens.comment;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else if (Syntax.isLine(line)) {\n      token.type        = Lexer.tokens.line;\n      token.indentation = RegExp.$1.length;\n      token.content     = RegExp.$2;\n    } else {\n      throw new Error(\"SyntaxError: Unknown line: \" + line);\n    }\n\n    return token;\n  },\n\n  pushToken: function (token) {\n    this.tokenStack.push(token);\n  },\n\n  pushDummyTokenByType: function (type) {\n    var token = new Token();\n    token.type = type;\n    this.tokenStack.push(token);\n  },\n\n  peekStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack[this.tokenStack.length - 1] : null;\n  },\n\n  getStackedToken: function () {\n    return this.tokenStack.length > 0 ?\n      this.tokenStack.pop() : null;\n  },\n\n  peekNextToken: function () {\n    return this.peekStackedToken() ||\n      this.tokenize(this.stream.peekNextLine());\n  },\n\n  getNextToken: function () {\n    return this.getStackedToken() ||\n      this.tokenize(this.stream.getNextLine());\n  },\n\n  hasNext: function () {\n    return this.stream.hasNext();\n  },\n\n  getLineNumber: function () {\n    return this.stream.lineNumber;\n  }\n};\n\nLexer.tokens = {};\n[\n  \"header\",\n  \"orderedListElement\",\n  \"unorderedListElement\",\n  \"tableRow\",\n  \"tableSeparator\",\n  \"preformatted\",\n  \"line\",\n  \"horizontalRule\",\n  \"blank\",\n  \"directive\",\n  \"comment\"\n].forEach(function (tokenName, i) {\n  Lexer.tokens[tokenName] = i;\n});\n\n// ------------------------------------------------------------\n// Exports\n// ------------------------------------------------------------\n\nif (typeof exports !== \"undefined\")\n  exports.Lexer = Lexer;\n","var Converter = require(\"./converter.js\").Converter;\nvar Node = require(\"../node.js\").Node;\n\nfunction ConverterHTML(orgDocument, exportOptions) {\n  this.initialize(orgDocument, exportOptions);\n  this.result = this.convert();\n}\n\nConverterHTML.prototype = {\n  __proto__: Converter.prototype,\n\n  convert: function () {\n    var title = this.orgDocument.title ? this.convertNode(this.orgDocument.title) : this.untitled;\n    var titleHTML = this.tag(\"h\" + Math.max(Number(this.headerOffset), 1), title);\n    var contentHTML = this.convertNodes(this.orgDocument.nodes, true /* record headers */);\n    var toc = this.computeToc(this.documentOptions[\"toc\"]);\n    var tocHTML = this.tocToHTML(toc);\n\n    return {\n      title: title,\n      titleHTML: titleHTML,\n      contentHTML: contentHTML,\n      tocHTML: tocHTML,\n      toc: toc,\n      toString: function () {\n        return titleHTML + tocHTML + \"\\n\" + contentHTML;\n      }\n    };\n  },\n\n  tocToHTML: function (toc) {\n    function tocToHTMLFunction(tocList) {\n      var html = \"\";\n      for (var i = 0; i < tocList.length; ++i) {\n        var tocItem = tocList[i];\n        var sectionNumberText = tocItem.headerNode.sectionNumberText;\n        var sectionNumber = this.documentOptions.num ?\n              this.inlineTag(\"span\", sectionNumberText, {\n                \"class\": \"section-number\"\n              }) : \"\";\n        var header = this.getNodeTextContent(tocItem.headerNode);\n        var headerLink = this.inlineTag(\"a\", sectionNumber + header, {\n          href: \"#header-\" + sectionNumberText.replace(/\\./g, \"-\")\n        });\n        var subList = tocItem.childTocs.length ? tocToHTMLFunction.call(this, tocItem.childTocs) : \"\";\n        html += this.tag(\"li\", headerLink + subList);\n      }\n      return this.tag(\"ul\", html);\n    }\n\n    return tocToHTMLFunction.call(this, toc);\n  },\n\n  computeAuxDataForNode: function (node) {\n    while (node.parent &&\n           node.parent.type === Node.types.inlineContainer) {\n      node = node.parent;\n    }\n    var attributesNode = node.previousSibling;\n    var attributesText = \"\";\n    while (attributesNode &&\n           attributesNode.type === Node.types.directive &&\n           attributesNode.directiveName === \"attr_html:\") {\n      attributesText += attributesNode.directiveRawValue + \" \";\n      attributesNode = attributesNode.previousSibling;\n    }\n    return attributesText;\n  },\n\n  // Method to construct org-js generated class\n  orgClassName: function (className) {\n    return this.exportOptions.htmlClassPrefix ?\n      this.exportOptions.htmlClassPrefix + className\n      : className;\n  },\n\n  // Method to construct org-js generated id\n  orgId: function (id) {\n    return this.exportOptions.htmlIdPrefix ?\n      this.exportOptions.htmlIdPrefix + id\n      : id;\n  },\n\n  // ----------------------------------------------------\n  // Node conversion\n  // ----------------------------------------------------\n\n  convertHeader: function (node, childText, auxData,\n                           taskStatus, sectionNumberText) {\n    var headerAttributes = {};\n\n    if (taskStatus) {\n      childText = this.inlineTag(\"span\", childText.substring(0, 4), {\n        \"class\": \"task-status \" + taskStatus\n      }) + childText.substring(5);\n    }\n\n    if (sectionNumberText) {\n      childText = this.inlineTag(\"span\", sectionNumberText, {\n        \"class\": \"section-number\"\n      }) + childText;\n      headerAttributes[\"id\"] = \"header-\" + sectionNumberText.replace(/\\./g, \"-\");\n    }\n\n    if (taskStatus)\n      headerAttributes[\"class\"] = \"task-status \" + taskStatus;\n\n    return this.tag(\"h\" + (this.headerOffset + node.level),\n                    childText, headerAttributes, auxData);\n  },\n\n  convertOrderedList: function (node, childText, auxData) {\n    return this.tag(\"ol\", childText, null, auxData);\n  },\n\n  convertUnorderedList: function (node, childText, auxData) {\n    return this.tag(\"ul\", childText, null, auxData);\n  },\n\n  convertDefinitionList: function (node, childText, auxData) {\n    return this.tag(\"dl\", childText, null, auxData);\n  },\n\n  convertDefinitionItem: function (node, childText, auxData,\n                                   term, definition) {\n    return this.tag(\"dt\", term) + this.tag(\"dd\", definition);\n  },\n\n  convertListItem: function (node, childText, auxData) {\n    if (this.exportOptions.suppressCheckboxHandling) {\n      return this.tag(\"li\", childText, null, auxData);\n    } else {\n      var listItemAttributes = {};\n      var listItemText = childText;\n      // Embed checkbox\n      if (/^\\s*\\[(X| |-)\\]([\\s\\S]*)/.exec(listItemText)) {\n        listItemText = RegExp.$2 ;\n        var checkboxIndicator = RegExp.$1;\n\n        var checkboxAttributes = { type: \"checkbox\" };\n        switch (checkboxIndicator) {\n        case \"X\":\n          checkboxAttributes[\"checked\"] = \"true\";\n          listItemAttributes[\"data-checkbox-status\"] = \"done\";\n          break;\n        case \"-\":\n          listItemAttributes[\"data-checkbox-status\"] = \"intermediate\";\n          break;\n        default:\n          listItemAttributes[\"data-checkbox-status\"] = \"undone\";\n          break;\n        }\n\n        listItemText = this.inlineTag(\"input\", null, checkboxAttributes) + listItemText;\n      }\n\n      return this.tag(\"li\", listItemText, listItemAttributes, auxData);\n    }\n  },\n\n  convertParagraph: function (node, childText, auxData) {\n    return this.tag(\"p\", childText, null, auxData);\n  },\n\n  convertPreformatted: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertTable: function (node, childText, auxData) {\n    return this.tag(\"table\", this.tag(\"tbody\", childText), null, auxData);\n  },\n\n  convertTableRow: function (node, childText, auxData) {\n    return this.tag(\"tr\", childText);\n  },\n\n  convertTableHeader: function (node, childText, auxData) {\n    return this.tag(\"th\", childText);\n  },\n\n  convertTableCell: function (node, childText, auxData) {\n    return this.tag(\"td\", childText);\n  },\n\n  convertHorizontalRule: function (node, childText, auxData) {\n    return this.tag(\"hr\", null, null, auxData);\n  },\n\n  convertInlineContainer: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertBold: function (node, childText, auxData) {\n    return this.inlineTag(\"b\", childText);\n  },\n\n  convertItalic: function (node, childText, auxData) {\n    return this.inlineTag(\"i\", childText);\n  },\n\n  convertUnderline: function (node, childText, auxData) {\n    return this.inlineTag(\"span\", childText, {\n      style: \"text-decoration:underline;\"\n    });\n  },\n\n  convertCode: function (node, childText, auxData) {\n    return this.inlineTag(\"code\", childText);\n  },\n\n  convertDashed: function (node, childText, auxData) {\n    return this.inlineTag(\"del\", childText);\n  },\n\n  convertLink: function (node, childText, auxData) {\n    var srcParameterStripped = this.stripParametersFromURL(node.src);\n    if (this.imageExtensionPattern.exec(srcParameterStripped)) {\n      var imgText = this.getNodeTextContent(node);\n      return this.inlineTag(\"img\", null, {\n        src: node.src,\n        alt: imgText,\n        title: imgText\n      }, auxData);\n    } else {\n      return this.inlineTag(\"a\", childText, { href: node.src });\n    }\n  },\n\n  convertQuote: function (node, childText, auxData) {\n    return this.tag(\"blockquote\", childText, null, auxData);\n  },\n\n  convertExample: function (node, childText, auxData) {\n    return this.tag(\"pre\", childText, null, auxData);\n  },\n\n  convertSrc: function (node, childText, auxData) {\n    var codeLanguage = node.directiveArguments.length\n          ? node.directiveArguments[0]\n          : \"unknown\";\n    childText = this.tag(\"code\", childText, {\n      \"class\": \"language-\" + codeLanguage\n    }, auxData);\n    return this.tag(\"pre\", childText, {\n      \"class\": \"prettyprint\"\n    });\n  },\n\n  // @override\n  convertHTML: function (node, childText, auxData) {\n    if (node.directiveName === \"html:\") {\n      return node.directiveRawValue;\n    } else if (node.directiveName === \"html\") {\n      return node.children.map(function (textNode) {\n        return textNode.value;\n      }).join(\"\\n\");\n    } else {\n      return childText;\n    }\n  },\n\n  // @implement\n  convertHeaderBlock: function (headerBlock, level, index) {\n    level = level || 0;\n    index = index || 0;\n\n    var contents = [];\n\n    var headerNode = headerBlock.header;\n    if (headerNode) {\n      contents.push(this.convertNode(headerNode));\n    }\n\n    var blockContent = this.convertNodes(headerBlock.childNodes);\n    contents.push(blockContent);\n\n    var childBlockContent = headerBlock.childBlocks\n          .map(function (block, idx) {\n            return this.convertHeaderBlock(block, level + 1, idx);\n          }, this)\n          .join(\"\\n\");\n    contents.push(childBlockContent);\n\n    var contentsText = contents.join(\"\\n\");\n\n    if (headerNode) {\n      return this.tag(\"section\", \"\\n\" + contents.join(\"\\n\"), {\n        \"class\": \"block block-level-\" + level\n      });\n    } else {\n      return contentsText;\n    }\n  },\n\n  // ----------------------------------------------------\n  // Supplemental methods\n  // ----------------------------------------------------\n\n  replaceMap: {\n    // [replacing pattern, predicate]\n    \"&\": [\"&#38;\", null],\n    \"<\": [\"&#60;\", null],\n    \">\": [\"&#62;\", null],\n    '\"': [\"&#34;\", null],\n    \"'\": [\"&#39;\", null],\n    \"->\": [\"&#10132;\", function (text, insideCodeElement) {\n      return this.exportOptions.translateSymbolArrow && !insideCodeElement;\n    }]\n  },\n\n  replaceRegexp: null,\n\n  // @implement @override\n  escapeSpecialChars: function (text, insideCodeElement) {\n    if (!this.replaceRegexp) {\n      this.replaceRegexp = new RegExp(Object.keys(this.replaceMap).join(\"|\"), \"g\");\n    }\n\n    var replaceMap = this.replaceMap;\n    var self = this;\n    return text.replace(this.replaceRegexp, function (matched) {\n      if (!replaceMap[matched]) {\n        throw Error(\"escapeSpecialChars: Invalid match\");\n      }\n\n      var predicate = replaceMap[matched][1];\n      if (typeof predicate === \"function\" &&\n          !predicate.call(self, text, insideCodeElement)) {\n        // Not fullfill the predicate\n        return matched;\n      }\n\n      return replaceMap[matched][0];\n    });\n  },\n\n  // @implement\n  postProcess: function (node, currentText, insideCodeElement) {\n    if (this.exportOptions.exportFromLineNumber &&\n        typeof node.fromLineNumber === \"number\") {\n      // Wrap with line number information\n      currentText = this.inlineTag(\"div\", currentText, {\n        \"data-line-number\": node.fromLineNumber\n      });\n    }\n    return currentText;\n  },\n\n  // @implement\n  makeLink: function (url) {\n    return \"<a href=\\\"\" + url + \"\\\">\" + decodeURIComponent(url) + \"</a>\";\n  },\n\n  // @implement\n  makeSubscript: function (match, body, subscript) {\n    return \"<span class=\\\"org-subscript-parent\\\">\" +\n      body +\n      \"</span><span class=\\\"org-subscript-child\\\">\" +\n      subscript +\n      \"</span>\";\n  },\n\n  // ----------------------------------------------------\n  // Specific methods\n  // ----------------------------------------------------\n\n  attributesObjectToString: function (attributesObject) {\n    var attributesString = \"\";\n    for (var attributeName in attributesObject) {\n      if (attributesObject.hasOwnProperty(attributeName)) {\n        var attributeValue = attributesObject[attributeName];\n        // To avoid id/class name conflicts with other frameworks,\n        // users can add arbitrary prefix to org-js generated\n        // ids/classes via exportOptions.\n        if (attributeName === \"class\") {\n          attributeValue = this.orgClassName(attributeValue);\n        } else if (attributeName === \"id\") {\n          attributeValue = this.orgId(attributeValue);\n        }\n        attributesString += \" \" + attributeName + \"=\\\"\" + attributeValue + \"\\\"\";\n      }\n    }\n    return attributesString;\n  },\n\n  inlineTag: function (name, innerText, attributesObject, auxAttributesText) {\n    attributesObject = attributesObject || {};\n\n    var htmlString = \"<\" + name;\n    // TODO: check duplicated attributes\n    if (auxAttributesText)\n      htmlString += \" \" + auxAttributesText;\n    htmlString += this.attributesObjectToString(attributesObject);\n\n    if (innerText === null)\n      return htmlString + \"/>\";\n\n    htmlString += \">\" + innerText + \"</\" + name + \">\";\n\n    return htmlString;\n  },\n\n  tag: function (name, innerText, attributesObject, auxAttributesText) {\n    return this.inlineTag(name, innerText, attributesObject, auxAttributesText) + \"\\n\";\n  }\n};\n\nif (typeof exports !== \"undefined\")\n  exports.ConverterHTML = ConverterHTML;\n","var Node = require(\"../node.js\").Node;\n\nfunction Converter() {\n}\n\nConverter.prototype = {\n  exportOptions: {\n    headerOffset: 1,\n    exportFromLineNumber: false,\n    suppressSubScriptHandling: false,\n    suppressAutoLink: false,\n    // HTML\n    translateSymbolArrow: false,\n    suppressCheckboxHandling: false,\n    // { \"directive:\": function (node, childText, auxData) {} }\n    customDirectiveHandler: null,\n    // e.g., \"org-js-\"\n    htmlClassPrefix: null,\n    htmlIdPrefix: null\n  },\n\n  untitled: \"Untitled\",\n  result: null,\n\n  // TODO: Manage TODO lists\n\n  initialize: function (orgDocument, exportOptions) {\n    this.orgDocument = orgDocument;\n    this.documentOptions = orgDocument.options || {};\n    this.exportOptions = exportOptions || {};\n\n    this.headers = [];\n    this.headerOffset =\n      typeof this.exportOptions.headerOffset === \"number\" ? this.exportOptions.headerOffset : 1;\n    this.sectionNumbers = [0];\n  },\n\n  createTocItem: function (headerNode, parentTocs) {\n    var childTocs = [];\n    childTocs.parent = parentTocs;\n    var tocItem = { headerNode: headerNode, childTocs: childTocs };\n    return tocItem;\n  },\n\n  computeToc: function (exportTocLevel) {\n    if (typeof exportTocLevel !== \"number\")\n      exportTocLevel = Infinity;\n\n    var toc = [];\n    toc.parent = null;\n\n    var previousLevel = 1;\n    var currentTocs = toc;  // first\n\n    for (var i = 0; i < this.headers.length; ++i) {\n      var headerNode = this.headers[i];\n\n      if (headerNode.level > exportTocLevel)\n        continue;\n\n      var levelDiff = headerNode.level - previousLevel;\n      if (levelDiff > 0) {\n        for (var j = 0; j < levelDiff; ++j) {\n          if (currentTocs.length === 0) {\n            // Create a dummy tocItem\n            var dummyHeader = Node.createHeader([], {\n              level: previousLevel + j\n            });\n            dummyHeader.sectionNumberText = \"\";\n            currentTocs.push(this.createTocItem(dummyHeader, currentTocs));\n          }\n          currentTocs = currentTocs[currentTocs.length - 1].childTocs;\n        }\n      } else if (levelDiff < 0) {\n        levelDiff = -levelDiff;\n        for (var k = 0; k < levelDiff; ++k) {\n          currentTocs = currentTocs.parent;\n        }\n      }\n\n      currentTocs.push(this.createTocItem(headerNode, currentTocs));\n\n      previousLevel = headerNode.level;\n    }\n\n    return toc;\n  },\n\n  convertNode: function (node, recordHeader, insideCodeElement) {\n    if (!insideCodeElement) {\n      if (node.type === Node.types.directive) {\n        if (node.directiveName === \"example\" ||\n            node.directiveName === \"src\") {\n          insideCodeElement = true;\n        }\n      } else if (node.type === Node.types.preformatted) {\n        insideCodeElement = true;\n      }\n    }\n\n    if (typeof node === \"string\") {\n      node = Node.createText(null, { value: node });\n    }\n\n    var childText = node.children ? this.convertNodesInternal(node.children, recordHeader, insideCodeElement) : \"\";\n    var text;\n\n    var auxData = this.computeAuxDataForNode(node);\n\n    switch (node.type) {\n    case Node.types.header:\n      // Parse task status\n      var taskStatus = null;\n      if (childText.indexOf(\"TODO \") === 0)\n        taskStatus = \"todo\";\n      else if (childText.indexOf(\"DONE \") === 0)\n        taskStatus = \"done\";\n\n      // Compute section number\n      var sectionNumberText = null;\n      if (recordHeader) {\n        var thisHeaderLevel = node.level;\n        var previousHeaderLevel = this.sectionNumbers.length;\n        if (thisHeaderLevel > previousHeaderLevel) {\n          // Fill missing section number\n          var levelDiff = thisHeaderLevel - previousHeaderLevel;\n          for (var j = 0; j < levelDiff; ++j) {\n            this.sectionNumbers[thisHeaderLevel - 1 - j] = 0; // Extend\n          }\n        } else if (thisHeaderLevel < previousHeaderLevel) {\n          this.sectionNumbers.length = thisHeaderLevel; // Collapse\n        }\n        this.sectionNumbers[thisHeaderLevel - 1]++;\n        sectionNumberText = this.sectionNumbers.join(\".\");\n        node.sectionNumberText = sectionNumberText; // Can be used in ToC\n      }\n\n      text = this.convertHeader(node, childText, auxData,\n                                taskStatus, sectionNumberText);\n\n      if (recordHeader)\n        this.headers.push(node);\n      break;\n    case Node.types.orderedList:\n      text = this.convertOrderedList(node, childText, auxData);\n      break;\n    case Node.types.unorderedList:\n      text = this.convertUnorderedList(node, childText, auxData);\n      break;\n    case Node.types.definitionList:\n      text = this.convertDefinitionList(node, childText, auxData);\n      break;\n    case Node.types.listElement:\n      if (node.isDefinitionList) {\n        var termText = this.convertNodesInternal(node.term, recordHeader, insideCodeElement);\n        text = this.convertDefinitionItem(node, childText, auxData,\n                                          termText, childText);\n      } else {\n        text = this.convertListItem(node, childText, auxData);\n      }\n      break;\n    case Node.types.paragraph:\n      text = this.convertParagraph(node, childText, auxData);\n      break;\n    case Node.types.preformatted:\n      text = this.convertPreformatted(node, childText, auxData);\n      break;\n    case Node.types.table:\n      text = this.convertTable(node, childText, auxData);\n      break;\n    case Node.types.tableRow:\n      text = this.convertTableRow(node, childText, auxData);\n      break;\n    case Node.types.tableCell:\n      if (node.isHeader)\n        text = this.convertTableHeader(node, childText, auxData);\n      else\n        text = this.convertTableCell(node, childText, auxData);\n      break;\n    case Node.types.horizontalRule:\n      text = this.convertHorizontalRule(node, childText, auxData);\n      break;\n      // ============================================================ //\n      // Inline\n      // ============================================================ //\n    case Node.types.inlineContainer:\n      text = this.convertInlineContainer(node, childText, auxData);\n      break;\n    case Node.types.bold:\n      text = this.convertBold(node, childText, auxData);\n      break;\n    case Node.types.italic:\n      text = this.convertItalic(node, childText, auxData);\n      break;\n    case Node.types.underline:\n      text = this.convertUnderline(node, childText, auxData);\n      break;\n    case Node.types.code:\n      text = this.convertCode(node, childText, auxData);\n      break;\n    case Node.types.dashed:\n      text = this.convertDashed(node, childText, auxData);\n      break;\n    case Node.types.link:\n      text = this.convertLink(node, childText, auxData);\n      break;\n    case Node.types.directive:\n      switch (node.directiveName) {\n      case \"quote\":\n        text = this.convertQuote(node, childText, auxData);\n        break;\n      case \"example\":\n        text = this.convertExample(node, childText, auxData);\n        break;\n      case \"src\":\n        text = this.convertSrc(node, childText, auxData);\n        break;\n      case \"html\":\n      case \"html:\":\n        text = this.convertHTML(node, childText, auxData);\n        break;\n      default:\n        if (this.exportOptions.customDirectiveHandler &&\n            this.exportOptions.customDirectiveHandler[node.directiveName]) {\n          text = this.exportOptions.customDirectiveHandler[node.directiveName](\n            node, childText, auxData\n          );\n        } else {\n          text = childText;\n        }\n      }\n      break;\n    case Node.types.text:\n      text = this.convertText(node.value, insideCodeElement);\n      break;\n    default:\n      throw Error(\"Unknown node type: \" + node.type);\n    }\n\n    if (typeof this.postProcess === \"function\") {\n      text = this.postProcess(node, text, insideCodeElement);\n    }\n\n    return text;\n  },\n\n  convertText: function (text, insideCodeElement) {\n    var escapedText = this.escapeSpecialChars(text, insideCodeElement);\n\n    if (!this.exportOptions.suppressSubScriptHandling && !insideCodeElement) {\n      escapedText = this.makeSubscripts(escapedText, insideCodeElement);\n    }\n    if (!this.exportOptions.suppressAutoLink) {\n      escapedText = this.linkURL(escapedText);\n    }\n\n    return escapedText;\n  },\n\n  // By default, ignore html\n  convertHTML: function (node, childText, auxData) {\n    return childText;\n  },\n\n  convertNodesInternal: function (nodes, recordHeader, insideCodeElement) {\n    var nodesTexts = [];\n    for (var i = 0; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var nodeText = this.convertNode(node, recordHeader, insideCodeElement);\n      nodesTexts.push(nodeText);\n    }\n    return this.combineNodesTexts(nodesTexts);\n  },\n\n  convertHeaderBlock: function (headerBlock, recordHeader) {\n    throw Error(\"convertHeaderBlock is not implemented\");\n  },\n\n  convertHeaderTree: function (headerTree, recordHeader) {\n    return this.convertHeaderBlock(headerTree, recordHeader);\n  },\n\n  convertNodesToHeaderTree: function (nodes, nextBlockBegin, blockHeader) {\n    var childBlocks = [];\n    var childNodes = [];\n\n    if (typeof nextBlockBegin === \"undefined\") {\n      nextBlockBegin = 0;\n    }\n    if (typeof blockHeader === \"undefined\") {\n      blockHeader = null;\n    }\n\n    for (var i = nextBlockBegin; i < nodes.length;) {\n      var node = nodes[i];\n\n      var isHeader = node.type === Node.types.header;\n\n      if (!isHeader) {\n        childNodes.push(node);\n        i = i + 1;\n        continue;\n      }\n\n      // Header\n      if (blockHeader && node.level <= blockHeader.level) {\n        // Finish Block\n        break;\n      } else {\n        // blockHeader.level < node.level\n        // Begin child block\n        var childBlock = this.convertNodesToHeaderTree(nodes, i + 1, node);\n        childBlocks.push(childBlock);\n        i = childBlock.nextIndex;\n      }\n    }\n\n    // Finish block\n    return {\n      header: blockHeader,\n      childNodes: childNodes,\n      nextIndex: i,\n      childBlocks: childBlocks\n    };\n  },\n\n  convertNodes: function (nodes, recordHeader, insideCodeElement) {\n    return this.convertNodesInternal(nodes, recordHeader, insideCodeElement);\n  },\n\n  combineNodesTexts: function (nodesTexts) {\n    return nodesTexts.join(\"\");\n  },\n\n  getNodeTextContent: function (node) {\n    if (node.type === Node.types.text)\n      return this.escapeSpecialChars(node.value);\n    else\n      return node.children ? node.children.map(this.getNodeTextContent, this).join(\"\") : \"\";\n  },\n\n  // @Override\n  escapeSpecialChars: function (text) {\n    throw Error(\"Implement escapeSpecialChars\");\n  },\n\n  // http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n  urlPattern: /\\b(?:https?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’])/ig,\n\n  // @Override\n  linkURL: function (text) {\n    var self = this;\n    return text.replace(this.urlPattern, function (matched) {\n      if (matched.indexOf(\"://\") < 0)\n        matched = \"http://\" + matched;\n      return self.makeLink(matched);\n    });\n  },\n\n  makeLink: function (url) {\n    throw Error(\"Implement makeLink\");\n  },\n\n  makeSubscripts: function (text) {\n    if (this.documentOptions[\"^\"] === \"{}\")\n      return text.replace(/\\b([^_ \\t]*)_{([^}]*)}/g,\n                          this.makeSubscript);\n    else if (this.documentOptions[\"^\"])\n      return text.replace(/\\b([^_ \\t]*)_([^_]*)\\b/g,\n                          this.makeSubscript);\n    else\n      return text;\n  },\n\n  makeSubscript: function (match, body, subscript) {\n    throw Error(\"Implement makeSubscript\");\n  },\n\n  stripParametersFromURL: function (url) {\n    return url.replace(/\\?.*$/, \"\");\n  },\n\n  imageExtensionPattern: new RegExp(\"(\" + [\n    \"bmp\", \"png\", \"jpeg\", \"jpg\", \"gif\", \"tiff\",\n    \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\", \"ppm\", \"svg\"\n  ].join(\"|\") + \")$\", \"i\")\n};\n\nif (typeof exports !== \"undefined\")\n  exports.Converter = Converter;\n","/**\n * Copyright (C) 2018  The Software Heritage developers\n * See the AUTHORS file at the top-level directory of this distribution\n * License: GNU Affero General Public License version 3, or any later version\n * See top-level LICENSE file for more information\n */\n\n// org-js chunk that will be lazily loaded\n\nimport './org.css';\nexport * from 'org';\n"],"sourceRoot":""}